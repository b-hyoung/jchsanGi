[
  {
    "title": "정보시스템 기반 기술",
    "comments": [
      {
        "problem_number": 1,
        "comment": "소프트웨어 설계는 재사용성과 확장성을 높이는 방향으로 해야 한다. \"재사용이 불가능하도록 설계\"는 설계 원칙에 반하는 설명이다."
      },
      {
        "problem_number": 2,
        "comment": "프로토콜입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 3,
        "comment": "실행(Running) 상태입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 4,
        "comment": "Adapter 패턴은 호환되지 않는 인터페이스를 연결해 기존 클래스를 재사용할 수 있게 해준다."
      },
      {
        "problem_number": 5,
        "comment": "가상기억장치는 보조기억장치의 일부를 주기억장치처럼 사용하는 개념이다. 실제 RAM을 보조기억장치처럼 쓰는 것이 아니다."
      },
      {
        "problem_number": 6,
        "comment": "RR(Round Robin)은 시간 할당량(Time Quantum)만큼씩 번갈아 CPU를 주는 선점형 스케줄링입니다.\n시간 할당량이 매우 커지면 한 번 CPU를 잡은 프로세스가 거의 끝날 때까지 실행되므로 선점 효과가 사실상 사라집니다.\n\n따라서 실행 순서는 도착 순서대로 한 번씩 처리하는 FCFS(FIFO)와 같은 형태에 가까워집니다."
      },
      {
        "problem_number": 7,
        "comment": "세그먼테이션은 프로그램을 의미 있는 단위(논리 단위)로 가변 크기 분할한다. 페이징은 고정 크기 분할이다."
      },
      {
        "problem_number": 8,
        "comment": "ICMP입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 9,
        "comment": "네트워크 계층입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 10,
        "comment": "UML입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 11,
        "comment": "Adapter입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 12,
        "comment": "Tomcat에 대한 설명이다. Java 기반 오픈소스 웹 애플리케이션 서버/서블릿 컨테이너로 사용된다."
      },
      {
        "problem_number": 13,
        "comment": "FCFS 디스크 스케줄링이므로 요청 대기열 순서(100, 180, 40, 120, 0, 130, 70, 80, 150, 200)를 그대로 따라갑니다.\n현재 헤드 위치는 50이므로 각 이동 구간의 절대값을 모두 더하면 총 이동 거리가 됩니다.\n\n구간별 이동 거리:\n- 50→100 = 50\n- 100→180 = 80\n- 180→40 = 140\n- 40→120 = 80\n- 120→0 = 120\n- 0→130 = 130\n- 130→70 = 60\n- 70→80 = 10\n- 80→150 = 70\n- 150→200 = 50\n- 총합 = 790"
      },
      {
        "problem_number": 14,
        "comment": "테스트 단계의 일반적인 순서는 단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트 순서다."
      },
      {
        "problem_number": 15,
        "comment": "비동기식입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 16,
        "comment": "Method입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 17,
        "comment": "강도 테스트입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 18,
        "comment": "구조적 반복입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 19,
        "comment": "문항의 조건에 따라 계산 또는 규칙을 적용하면 결과값은 5입니다. 따라서 5를 고르는 것이 맞습니다."
      },
      {
        "problem_number": 20,
        "comment": "SOA입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      }
    ]
  },
  {
    "title": "프로그래밍 언어 활용",
    "comments": [
      {
        "problem_number": 21,
        "comment": "HTML form 태그의 기본 구조는 `<form method=\"...\" action=\"...\"> ... </form>` 이다. 각 빈칸은 form, method, action, /form 순으로 들어간다."
      },
      {
        "problem_number": 22,
        "comment": "ObjectInputStream입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 23,
        "comment": "return입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 24,
        "comment": "구조체 변수 `r`의 멤버를 인자로 전달해야 하므로 `calc(r.x, r.y)` 형태가 맞다."
      },
      {
        "problem_number": 25,
        "comment": "document.write(100)입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 26,
        "comment": "㉠-do, ㉡-while입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 27,
        "comment": "%입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 28,
        "comment": "3edc입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 29,
        "comment": "fscanf입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 30,
        "comment": "Content Coupling입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 31,
        "comment": "결합도는 약할수록 바람직하다. 강한 결합도는 모듈 간 의존성을 높여 유지보수를 어렵게 만든다."
      },
      {
        "problem_number": 32,
        "comment": "상속은 부모 클래스의 속성과 메서드를 물려받아 자식 클래스에서 구체화/확장하는 개념이다."
      },
      {
        "problem_number": 33,
        "comment": "문자열 저장은 `String` 자료형을 사용한다. `char`는 문자 1개 저장용이다."
      },
      {
        "problem_number": 34,
        "comment": "C++ 예외 처리는 보통 `try-catch`를 사용한다. `finally`는 C++의 기본 예외 처리 문법이 아니다."
      },
      {
        "problem_number": 35,
        "comment": "`unsigned`는 정수형에 사용하는 한정자다. `double`에 `unsigned`를 붙이는 것은 올바르지 않다."
      },
      {
        "problem_number": 36,
        "comment": "required입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 37,
        "comment": "`splice()`는 배열 요소를 삭제/추가/교체하며 원본 배열을 변경한다. 지정 범위를 단순 조회하는 설명은 `slice()`에 가깝다."
      },
      {
        "problem_number": 38,
        "comment": "&&입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 39,
        "comment": "절차적 응집도입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 40,
        "comment": "설명은 상속에 가깝다. 캡슐화는 데이터와 메서드를 하나로 묶고 외부에서 직접 접근을 제한하는 개념이다."
      }
    ]
  },
  {
    "title": "데이터베이스의 활용",
    "comments": [
      {
        "problem_number": 41,
        "comment": "INSERT입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 42,
        "comment": "뷰(View)는 기본 테이블에서 유도되는 가상 테이블이다. 물리적으로 독립 저장되는 실제 테이블이라는 설명은 틀리다."
      },
      {
        "problem_number": 43,
        "comment": "`DISTINCT`는 중복을 제거한다. 학과 목록을 중복 없이 조회하는 SQL문은 `SELECT DISTINCT DEPT FROM STUDENT;` 이다."
      },
      {
        "problem_number": 44,
        "comment": "NULL은 0이나 공백이 아니라 값이 없거나 미정 상태를 의미하는 널 값(Null Value)이다."
      },
      {
        "problem_number": 45,
        "comment": "관계형 데이터 모델입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 46,
        "comment": "관계대수는 연산 순서를 명시하는 절차적 언어다. 비절차적 특징은 관계해석에 해당한다."
      },
      {
        "problem_number": 47,
        "comment": "⋈입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 48,
        "comment": "시스템 카탈로그는 DBMS가 관리하며 일반 사용자가 SQL로 직접 갱신하는 것은 허용되지 않는다."
      },
      {
        "problem_number": 49,
        "comment": "데크입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 50,
        "comment": "3, 4, 5, 2, 1입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 51,
        "comment": "DROP입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 52,
        "comment": "부분 함수 종속성 제거입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 53,
        "comment": "각 SQL문이 “중복 제거 여부”와 “조건 적용 결과”를 어떻게 만드는지 순서대로 보면 됩니다.\n\n주어진 데이터:\n- 컴퓨터정보과 120명\n- 인터넷정보과 160명\n- 사무자동화과 80명\n- 총 학생 수 = 120 + 160 + 80 = 360명\n\nSQL별 결과:\n- ㉠ `SELECT DISTINCT DEPT FROM STUDENT;`\n  → 학과명을 중복 제거해서 조회하므로 학과 종류 수 = 3\n- ㉡ `SELECT DEPT FROM STUDENT;`\n  → 중복 제거 없이 모든 학생의 학과를 조회하므로 튜플 수 = 전체 학생 수 = 360\n- ㉢ `SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = ‘컴퓨터정보과’;`\n  → WHERE 절로 컴퓨터정보과만 남기면 DEPT 값은 하나뿐이고, DISTINCT 후 COUNT 결과는 1"
      },
      {
        "problem_number": 54,
        "comment": "개체 타입입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 55,
        "comment": "튜플입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 56,
        "comment": "`LIKE`에서 `_`(언더스코어)는 “임의의 한 글자”를 의미합니다.\n따라서 `LIKE '박__'` 는 “박으로 시작하는 정확히 3글자 이름”을 뜻합니다.\n\n문제의 조건은 `NOT LIKE '박__'` 이므로, 위 조건에 해당하는 이름을 제외한다는 의미입니다.\n\n정리하면:\n- 제외 대상: 박으로 시작하는 3글자 이름\n- 조회 대상: 박으로 시작하지 않는 3글자 이름 (보기 표현 기준)"
      },
      {
        "problem_number": 57,
        "comment": "   입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 58,
        "comment": "직접 파일입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 59,
        "comment": "운영 기능입니다. 다른 선택지는 용어의 의미나 적용 범위가 달라 문제의 조건에 맞지 않습니다."
      },
      {
        "problem_number": 60,
        "comment": "데이터베이스 설계 절차는 일반적으로 요구 조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 순서로 진행한다."
      }
    ]
  }
]
