{
  "format": "random-option-shuffle-year-v1",
  "year": 2024,
  "generatedAt": "2026-02-22T18:57:49.637Z",
  "sessions": [
    {
      "key": "2024-1",
      "sessionId": "1"
    },
    {
      "key": "2024-2",
      "sessionId": "4"
    },
    {
      "key": "2024-3",
      "sessionId": "5"
    }
  ],
  "items": [
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 1,
      "subject": 1,
      "question_text": "라우팅(Routing) 프로토콜이 아닌 것은?",
      "options": [
        "BGP",
        "OSPF",
        "SMTP",
        "RIP"
      ],
      "examples": null,
      "answer_text": "SMTP",
      "comment_text": "SMTP(Simple Mail Transfer Protocol)는 전자 우편을 전송하는 프로토콜입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 2,
      "subject": 1,
      "question_text": "디렉터리 구조 중 중앙에 마스터 파일 디렉터리가 있고, 그 아래에 사용자별로 서로 다른 파일 디렉터리가 있는 구조는?",
      "options": [
        "1단계 디렉터리 구조",
        "2단계 디렉터리 구조",
        "트리 디렉터리 구조",
        "비순환 그래프 디렉터리 구조"
      ],
      "examples": null,
      "answer_text": "2단계 디렉터리 구조",
      "comment_text": "중앙에 마스터 파일 디렉터리가 있고, 그 아래에 사용자별로 서로 다른 파일 디렉터리가 있는 구조는 2단계 디렉터리 구조입니다. ·1단계(단일) 디렉터리 구조 : 가장 간단하고, 모든 파일이 하나의 디렉터리 내에 위치하여 관리되는 구조 ·트리 디렉터리 구조 : 하나의 루트 디렉터리와 여러 개의 종속(서브) 디렉터리로 구성된 구조 ·비순환(비주기) 그래프 디렉터리 구조 : 하위 파일이나 하위 디렉터리를 공동으로 사용할 수 있는 것으로, 사이클이 허용되지 않는 구조"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 3,
      "subject": 1,
      "question_text": "프로세스의 정의 중 틀린 것은?",
      "options": [
        "동기적 행위를 일으키는 주체",
        "실행중인 프로그램",
        "PCB를 가진 프로그램",
        "프로세서가 할당되는 실체"
      ],
      "examples": null,
      "answer_text": "동기적 행위를 일으키는 주체",
      "comment_text": "프로세스는 비동기적 행위를 일으키는 주체입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 4,
      "subject": 1,
      "question_text": "아키텍처 설계에서 뷰의 종류가 아닌 것은?",
      "options": [
        "물리적 뷰",
        "논리적 뷰",
        "프로세스 뷰",
        "배포 뷰"
      ],
      "examples": null,
      "answer_text": "물리적 뷰",
      "comment_text": "소프트웨어 아키텍처 뷰에는 유스케이스 뷰, 논리적 뷰, 구현 뷰, 배포 뷰, 프로세스 뷰가 있습니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 5,
      "subject": 1,
      "question_text": "사용자 인터페이스(User Interface)에 대한 설명으로 틀린 것은?",
      "options": [
        "사용자와 시스템이 정보를 주고받는 상호 작용이 잘 이루어지도록 하는 장치나 소프트웨어를 의미한다.",
        "편리한 유지보수를 위해 개발자 중심으로 설계되어야 한다.",
        "배우기가 용이하고 쉽게 사용할 수 있도록 만들어져야 한다.",
        "사용자 요구사항이 UI에 반영될 수 있도록 구성해야 한다."
      ],
      "examples": null,
      "answer_text": "편리한 유지보수를 위해 개발자 중심으로 설계되어야 한다.",
      "comment_text": "사용자 인터페이스(UI)는 사용자가 쉽게 이해하고 편리하게 사용할 수 있도록 사용자 중심으로 설계되어야 합니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 6,
      "subject": 1,
      "question_text": "GoF(Gang of Four)의 디자인 패턴 중 데코레이터(Decorator)에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "구조 패턴에 속한다.",
        "호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해준다.",
        "객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있다.",
        "임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현한다."
      ],
      "examples": null,
      "answer_text": "호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해준다.",
      "comment_text": "②번은 어댑터(Adapter) 패턴에 대한 설명입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 7,
      "subject": 1,
      "question_text": "RR(Round Robin) 스케줄링에서 시간 할당량이 커질 경우 어떤 스케줄링과 같은 효과를 얻는가?",
      "options": [
        "HRN",
        "FCFS(FIFO)",
        "SJF",
        "SRT"
      ],
      "examples": null,
      "answer_text": "FCFS(FIFO)",
      "comment_text": "RR(Round Robin) 기법은 할당되는 시간이 클 경우 FCFS 기법과 같아집니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 8,
      "subject": 1,
      "question_text": "FIFO 스케줄링에서 작업 도착 시간과 CPU 사용 시간은 다음 표와 같다. 모든 작업들의 평균 대기 시간은 얼마인가?",
      "options": [
        "5",
        "5.5",
        "13.75",
        "3.25"
      ],
      "examples": "작업|도착 시간|CPU 사용시간\n1|0|4\n2|1|10\n3|4|1\n4|8|7",
      "answer_text": "5",
      "comment_text": "FIFO는 준비상태 큐에 도착한 순서대로 작업을 수행하므로, 다음과 같은 순서로 수행됩니다. 진행 시간 0 0 4 4 작업 1 도착실행 완료 실행 시작 1 3 4 10 10 작업 2 도착 대기 실행 실행 시작 14 완료 1 실행 14 15 4 10 작업 3 도착 대기 실행 완료 시작 작업 4 8 7 도착 대기 15 7 실행 실행 시작 20 .. 평균 대기 시간: (0+3+10+7)/4 = 5시간"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 9,
      "subject": 1,
      "question_text": "소프트웨어 아키텍처 설계 시 고려사항이 아닌 것은?",
      "options": [
        "개발자와 사용자 간의 의사소통 도구로 활용될 수 있어야 한다.",
        "이해하기 쉽고, 명확하게 작성해야 한다.",
        "재사용이 불가능하도록 설계해야 한다.",
        "이해 관계자들의 품질 요구사항을 반영하여 품질 속성을 결정한다."
      ],
      "examples": null,
      "answer_text": "재사용이 불가능하도록 설계해야 한다.",
      "comment_text": "소프트웨어 아키텍처는 재사용이 가능하도록 설계해야 합니다. 소프트웨어 아키텍처 설계의 기본 원리 중 모듈화가 바로 재사용이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미합니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 10,
      "subject": 1,
      "question_text": "다음 중 가장 결합도가 강한 것은?",
      "options": [
        "Data Coupling",
        "Stamp Coupling",
        "Content Coupling",
        "Control Coupling"
      ],
      "examples": null,
      "answer_text": "Content Coupling",
      "comment_text": "결합도를 약한 것부터 강한 것 순으로 나열하면 '자료 결합도(Data Coupling) → 스탬프(검인) 결합도(Stamp Coupling) → 제어 결합도(Control Coupling) → 외부 결합도(External Coupling) → 공통(공유) 결합도(Common Coupling) → 내용 결합도(Content Coupling)'입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 11,
      "subject": 1,
      "question_text": "다음 중 빌드 자동화 도구가 아닌 것은?",
      "options": [
        "Fedora",
        "Gradle",
        "Jenkins",
        "Maven"
      ],
      "examples": null,
      "answer_text": "Fedora",
      "comment_text": "Fedora는 운영체제의 한 종류입니다. 자동화 도구에는 Ant, Maven, Gradle, Jenkins 등이 있습니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 12,
      "subject": 1,
      "question_text": "UNIX 시스템에서 파일의 권한 모드 설정에 관한 명령어는?",
      "options": [
        "chmod",
        "cp",
        "ls",
        "chown"
      ],
      "examples": null,
      "answer_text": "chmod",
      "comment_text": "UNIX 시스템에서 파일의 권한 모드 설정에 관한 명령어는 chmod입니다. ·cp: 파일을 복사함 ·ls: 현재 디렉터리 내의 파일 목록을 확인함 ·chown: 소유자를 변경함"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 13,
      "subject": 1,
      "question_text": "소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동은?",
      "options": [
        "정규화",
        "프로토타입",
        "통합 테스트",
        "형상 관리"
      ],
      "examples": null,
      "answer_text": "형상 관리",
      "comment_text": "소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동을 형상 관리라고 합니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 14,
      "subject": 1,
      "question_text": "LAN의 한 종류인 100Base-T 네트워크에서 사용되는 전송 매체는?",
      "options": [
        "Coaxial cable",
        "Optical cable",
        "UTP cable",
        "Microwave cable"
      ],
      "examples": null,
      "answer_text": "UTP cable",
      "comment_text": "100Base-T는 고속 이더넷(Fast Ethernet)이라고도 불리는 이더넷의 고속 버전으로, CSMA/CD를 사용하며, UTP(Unshielded Twisted Pair) 케이블을 이용해 100Mbps의 속도로 데이터를 전송합니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 15,
      "subject": 1,
      "question_text": "연산 P, V와 정수 변수를 이용하여 동기화 문제를 해결하는 것은?",
      "options": [
        "Critical Section",
        "Monitor",
        "Semaphore",
        "Mutual Exclusion"
      ],
      "examples": null,
      "answer_text": "Semaphore",
      "comment_text": "연산 P, V와 정수 변수를 이용하여 동기화 문제를 해결하는 것은 세마포어(Semaphore)입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 16,
      "subject": 1,
      "question_text": "파이프 필터 형태의 소프트웨어 아키텍처에 대한 설명으로 옳은 것은?",
      "options": [
        "노드와 간선으로 구성된다.",
        "계층 모델이라고도 한다.",
        "서브 시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복한다.",
        "3개의 서브 시스템(모델, 뷰, 제어)으로 구성되어 있다."
      ],
      "examples": null,
      "answer_text": "서브 시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복한다.",
      "comment_text": "파이프-필터 패턴에 대한 설명으로 옳은 것은 ③번입니다. ·①번은 피어-투-피어 패턴, ②번은 레이어 패턴, ④번은 모델-뷰-컨트롤러 패턴에 대한 설명입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 17,
      "subject": 1,
      "question_text": "다음 설명에 해당하는 용어는? 소프트웨어의 구현 단계에서 발생할 수 있는 보안 취약점들을 최소화하기 위해 보안 요소들을 고려하며 코딩하는 것을 의미하며, 보안 취약점을 사전에 대응하여 안정성과 신뢰성을 확보하기 위해 사용된다.",
      "options": [
        "SDLC",
        "Secure Coding",
        "CLASP",
        "OWASP"
      ],
      "examples": null,
      "answer_text": "Secure Coding",
      "comment_text": "문제의 설명은 Secure Coding에 대한 설명입니다. · 소프트웨어 개발 생명 주기(SDLC; Software Development Life Cycle): 소프트웨어 개발 방법론의 바탕이 되는 것으로, 소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 과정을 각 단계별로 나눈 것 · CLASP: Secure Software 사에서 개발하였으며, SDLC의 초기 단계에서 보안을 강화하기 위해 개발된 방법론 · OWASP(the Open Web Security Project, 오픈 웹 애플리케이션 보안 프로젝트) : 웹 정보 노출이나 악성 코드, 스크립트, 보안이 취약한 부분을 연구하는 비영리 단체"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 18,
      "subject": 1,
      "question_text": "데이터 전송 방식 중 패킷 교환 방식에 대한 설명으로 틀린 것은?",
      "options": [
        "가상 회선 방식과 데이터그램 방식이 있다.",
        "전송에 실패한 패킷의 경우 재전송이 가능하다.",
        "패킷 단위로 헤더를 추가하므로 패킷별 오버헤드가 발생한다.",
        "실시간 전송이나 대량의 데이터 전송에 적합하다."
      ],
      "examples": null,
      "answer_text": "실시간 전송이나 대량의 데이터 전송에 적합하다.",
      "comment_text": "실시간 전송이나, 대량의 데이터 전송에 가장 적합한 것은 회선 교환 방식입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 19,
      "subject": 1,
      "question_text": "자원 보호 기법 중 접근 제어 행렬에서 수평으로 있는 각 행들만을 따온 것으로서 각 영역에 대한 권한은 객체와 그 객체에 허용된 연산자로 구성되는 것은?",
      "options": [
        "Global Table",
        "Access Control List",
        "Capability List",
        "Lock/Key"
      ],
      "examples": null,
      "answer_text": "Capability List",
      "comment_text": "접근 제어 행렬에서 수평으로 있는 각 행들만을 따온 것으로서 각 영역에 대한 권한은 객체와 그 객체에 허용된 연산자로 구성되는 것은 권한 리스트(Capability List)입니다. ·전역 테이블(Global Table) : 가장 단순한 구현 방법으로, 세 개의 순서쌍인 영역, 객체, 접근 권한의 집합을 목록 형태로 구성한 기법 ·접근 제어 리스트(Access Control List) : 접근 제어 행렬에 있는 각 열, 즉 객체를 중심으로 접근 리스트를 구성한 기법 ·록-키(Lock-Key) : 접근 제어 리스트와 권한 리스트를 절충한 기법으로, 각 객체는 Lock, 각 영역은 Key라 불리는 유일하고도 독특한 값을 갖고 있어서 영역과 객체가 일치하는 경우에만 해당 객체를 접근할 수 있음"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 20,
      "subject": 1,
      "question_text": "가상기억장치에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "기억공간의 확장을 위한 것이다.",
        "주소 변환 작업이 필요하다.",
        "소프트웨어적인 방법이다.",
        "주기억장치를 보조기억장치처럼 사용한다."
      ],
      "examples": null,
      "answer_text": "주기억장치를 보조기억장치처럼 사용한다.",
      "comment_text": "가상기억장치는 보조기억장치의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법이다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 21,
      "subject": 2,
      "question_text": "다음은 아이디와 암호를 입력하는 로그인 창을 JavaScript로 구현한 것이다. 괄호(①~②)에 들어갈 적합한 속성은? <html> <body> <( )( )=\"post\" ( )=\"log01.jsp\"> <p>아이디<input type=\"text\" name=\"id\"></p> <p>암호<input type=\"password\" name=\"pw\"></p> <( )> </body> </html>",
      "options": [
        "㉠ form, ㉡ action, ㉢ method, ㉣ /form",
        "㉠ form, ㉡ method, ㉢ action, ㉣ /form",
        "㉠ function, ㉡ form, ㉢ method, ㉣ function",
        "㉠ function, ㉡ action, ㉢ form, ㉣ /function"
      ],
      "examples": null,
      "answer_text": "㉠ form, ㉡ method, ㉢ action, ㉣ /form",
      "comment_text": "사용된 코드의 의미는 다음과 같습니다. <html> <body> • <form method=\"post\" action=\"log01.jsp\"> 2 <p>아이디<input type=\"text\" name=\"id\"></p> 3 <p>암호<input type=\"password\" name=\"pw\"></p> 4 </form> </body> </html> 12~3번으로 입력받은 데이터를 Header와 Body에 첨부하여 'log01.jsp'로 전송한다. ·form: 사용자로부터 데이터를 입력받고 전송할 때 사용하는 태그 method: 데이터를 전송하는 방법을 명시하는 속성 post: 메시지의 Header와 Body에 데이터를 첨부하는 방식 get: URL에 데이터를 첨부하는 방식 action: 데이터가 도착할 URL을 표시하는 속성 ② “아이디” 이후에 문자열이 입력될 필드를 생성한다. 전송 후 데이터를 참조할 때 사용할 이름은 'id'이다. · input: 사용자로부터 입력을 받기 위한 요소들을 생성하는 태그 ·type: 생성할 요소의 종류 text: 텍스트를 입력받는 필드를 표시함 password: text와 동일하나 입력된 값이 '*'로 표시됨 submit : 클릭하면 form에 입력된 값들을 전송하는 단추를 표시함 ·name: form 태그를 통해 데이터가 전송된 후 해당 데이터를 참조하는 데 사용될 이름을 지정함 ③ “암호” 이후에 암호가 입력될 필드를 생성한다. 전송 후 데이터를 참조할 때 사용할 이름은 'pw'이다. ④ form 태그의 끝을 알리는 종료 태그이다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 22,
      "subject": 2,
      "question_text": "특정 모듈에 대해서 존재하는 처리 요소들 간의 기능적 연관성을 의미하는 것으로 입력이나 에러 처리 같은 유사한 기능을 행하는 요소끼리 하나의 요소로 묶는 응집도는?",
      "options": [
        "교환적 응집도",
        "순차적 응집도",
        "논리적 응집도",
        "절차적 응집도"
      ],
      "examples": null,
      "answer_text": "논리적 응집도",
      "comment_text": "문제에서 설명하는 응집도는 논리적 응집도입니다. ·교환(통신)적 응집도(Communication Cohesion): 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도 ·순차적 응집도(Sequential Cohesion) : 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도 ·절차적 응집도(Procedural Cohesion): 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 23,
      "subject": 2,
      "question_text": "다음 중 가장 결합도가 강한 것은?",
      "options": [
        "Data Coupling",
        "Stamp Coupling",
        "Content Coupling",
        "Control Coupling"
      ],
      "examples": null,
      "answer_text": "Content Coupling",
      "comment_text": "결합도를 약한 것부터 강한 것 순으로 나열하면 '자료 결합도(Data Coupling) → 스탬프(검인) 결합도(Stamp Coupling) → 제어 결합도(Control Coupling) → 외부 결합도(External Coupling) → 공통(공유) 결합도(Common Coupling) → 내용 결합도(Content Coupling)'입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 24,
      "subject": 2,
      "question_text": "C언어에서 상수를 정의할 때 사용하는 예약어는?",
      "options": [
        "#include",
        "#define",
        "#valuable",
        "#function"
      ],
      "examples": null,
      "answer_text": "#define",
      "comment_text": "C언어에서는 상수를 만들 때, #define [이름] [데이터] 또는 const [자료형] [이름] = [데이터]를 사용합니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 25,
      "subject": 2,
      "question_text": "외부 변수(External Variable)에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "외부 변수는 함수 밖에서 선언한다.",
        "초기화하지 않으면 자동으로 0으로 초기화 된다.",
        "함수가 종료되면 값도 소멸된다.",
        "다른 파일에서 선언된 변수를 참조할 경우 초기화 할 수 없다."
      ],
      "examples": null,
      "answer_text": "함수가 종료되면 값도 소멸된다.",
      "comment_text": "외부 변수는 함수가 종료되어도 기존에 저장된 값을 그대로 갖고 있습니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 26,
      "subject": 2,
      "question_text": "다음은 1000까지의 7의 배수를 모두 합하는 JavaScript 코드이다. 괄호(㉠, ㉡)에 들어갈 알맞은 예약어는? ……생략… <script> var r = 0, i = 0; ( ㉠ ) { i = i + 1; if (i%7 == 0) { r = r + i; } } ( ㉡ ) (i < 1000); console.log(r); </script> ……생략…",
      "options": [
        "-do,-while",
        "-while,-do",
        "-do, -loop",
        "-loop,-do"
      ],
      "examples": null,
      "answer_text": "-do,-while",
      "comment_text": "사용된 코드의 의미는 다음과 같습니다. ……생략… <script> 1 var r = 0, i = 0; do { i = i + 1; if (i%7 == 0) { r = r + i; } } while (i < 1000); console.log(r); </script> ……생략… ● 변수 r과 i를 선언하고 모두 0으로 초기화한다. ② do~while 반복문의 시작점이다. 3~6번 문장을 반복 수행한다. ③ i의 값을 1씩 누적시킨다. ④ i를 7로 나눈 나머지가 0이면 6번으로 이동하고, 아니면 6번으로 이동한다. ⑤ r에 i의 값을 누적시킨다. ⑥ i가 1000보다 작은 동안 3~6번 문장을 반복 수행한다. ※ 반복문 실행에 따른 변수들의 값의 변화는 다음과 같다. r 0 i 0 1 2 : : 6 7 7 8 : : 14 21 : : 994 71071 995 996 997 998 999 1000 ● 콘솔에 r의 값을 출력한다. 결과 71071"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 27,
      "subject": 2,
      "question_text": "자바스크립트에서 배열에 데이터를 입력하고자 할 때 사용하는 메소드는?",
      "options": [
        "push",
        "add",
        "pop",
        "shift"
      ],
      "examples": null,
      "answer_text": "push",
      "comment_text": "자바스크립트에서 배열에 데이터를 추가할 때는 push()와 unshift() 메소드를 사용합니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 28,
      "subject": 2,
      "question_text": "다음과 같이 HTML 문서를 작성했을 때 노란색 배경을 갖는 셀의 위치는? <html> <style> tr:nth-child(even) { background-color: yellow; } </style> <body> <table> <thead> <tr> <th></th> </tr> </thead> <tfoot> <tr> <td></td> </tr> </tfoot> <tbody> <tr> <td></td> </tr> <tr> <td></td> </tr> </tbody> </table> </body> </html>",
      "options": [
        "1행",
        "2행",
        "3행",
        "4행"
      ],
      "examples": null,
      "answer_text": "3행",
      "comment_text": "tr:nth-child(even)은 전체 테이블 기준이 아니라, 각 부모(thead, tbody, tfoot) 내부에서 짝수 tr을 고릅니다.\nthead는 tr 1개뿐 → 선택 없음\ntfoot도 tr 1개뿐 → 선택 없음\ntbody는 tr 2개 → 2번째 tr만 선택됨\n화면에서 그 tbody의 2번째 행이 보통 3행으로 보이므로 정답이 3번입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 29,
      "subject": 2,
      "question_text": "다음 중 C 언어에서 수학 함수를 사용하기 위해 추가해야 하는 라이브러리는?",
      "options": [
        "stdio.h",
        "math.h",
        "stdlib.h",
        "time.h"
      ],
      "examples": null,
      "answer_text": "math.h",
      "comment_text": "제곱근, 절대값 등을 구하기 위한 다양한 수학 함수는 math.h에 포함되어 있습니다. · stdio.h : 데이터의 입·출력에 사용되는 기능들을 제공함 · stdlib.h: 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기능들을 제공함 · time.h: 시간 처리에 사용되는 기능들을 제공함"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 30,
      "subject": 2,
      "question_text": "객체지향의 주요 개념에 대한 설명으로 틀린 것은?",
      "options": [
        "캡슐화는 상위 클래스에서 속성이나 연산을 전달받아 새로운 형태의 클래스로 확장하여 사용하는 것을 의미한다.",
        "객체는 실세계에 존재하거나 생각할 수 있는 것을 말한다.",
        "클래스는 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 것이다.",
        "다형성은 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질이다."
      ],
      "examples": null,
      "answer_text": "캡슐화는 상위 클래스에서 속성이나 연산을 전달받아 새로운 형태의 클래스로 확장하여 사용하는 것을 의미한다.",
      "comment_text": "①번은 상속(inheritance)에 대한 설명입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 31,
      "subject": 2,
      "question_text": "바람직한 소프트웨어 설계 지침이 아닌 것은?",
      "options": [
        "적당한 모듈의 크기를 유지한다.",
        "모듈 간의 접속 관계를 분석하여 복잡도와 중복을 줄인다.",
        "모듈 간의 결합도는 강할수록 바람직하다.",
        "모듈 간의 효과적인 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 한다."
      ],
      "examples": null,
      "answer_text": "모듈 간의 결합도는 강할수록 바람직하다.",
      "comment_text": "모듈 간의 결합도가 약할수록 바람직한 설계입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 32,
      "subject": 2,
      "question_text": "추상 클래스에 대한 설명으로 틀린 것은?",
      "options": [
        "자식 클래스에서 구현하려는 기능들의 공통점만을 모은 것이다.",
        "인스턴스 생성이 불가능하다.",
        "부모 클래스에서 상속받아 구체화한다.",
        "자식 클래스의 인스턴스를 생성하는 방식으로 사용한다."
      ],
      "examples": null,
      "answer_text": "부모 클래스에서 상속받아 구체화한다.",
      "comment_text": "③번은 자식 클래스에 대한 설명입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 33,
      "subject": 2,
      "question_text": "JavaScript에서 다음 그림과 같은 창을 띄우기 위해 사용한 명령어로 옳은 것은? 이 페이지 내용: title default 확인 취소",
      "options": [
        "alert(\"title\", \"default\")",
        "prompt(\"title\", \"default\")",
        "alert(\"default\", \"title\")",
        "prompt(\"default\", \"title\")"
      ],
      "examples": null,
      "answer_text": "prompt(\"title\", \"default\")",
      "comment_text": "문제의 그림은 JavaScript의 prompt('title', 'default') 명령문의 결과입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 34,
      "subject": 2,
      "question_text": "모듈을 설계하기 위해서 바람직한 응집도(Cohesion)와 결합도(Coupling)의 관계는?",
      "options": [
        "응집도는 약하고 결합도는 강해야 한다.",
        "응집도는 강하고 결합도는 약해야 한다.",
        "응집도도 약하고 결합도도 약해야 한다.",
        "응집도도 강하고 결합도도 강해야 한다."
      ],
      "examples": null,
      "answer_text": "응집도는 강하고 결합도는 약해야 한다.",
      "comment_text": "모듈은 독립성이 높을수록 좋은 모듈이라 할 수 있으며, 독립성을 높이려면 응집도는 강하고 결합도는 약해야 한다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 35,
      "subject": 2,
      "question_text": "다음 자바 프로그램 조건문에 대해 삼항 조건 연산자를 사용하여 옳게 나타낸 것은? if (a > b) max = a; else if (a <= b) max = b;",
      "options": [
        "max = (a > b)? a: b;",
        "(a > b)? max = a: max = b;",
        "max = (a <= b)? a: b;",
        "(a <= b)? max = a: max = b;"
      ],
      "examples": null,
      "answer_text": "max = (a > b)? a: b;",
      "comment_text": "·지문의 코드는 a가 b보다 크면 max에 a의 값을 저장하고, a가 b보다 크지 않으면 max에 b의 값을 저장하는 if문입니다. · 조건에 맞는 식은 ①번과 ②번이지만, 삼항 연산자의 각 항에는 삼항 연산자보다 우선순위가 높은 대입 연산자나 순서 연산자를 사용하지 못하므로 ①번이 답입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 36,
      "subject": 2,
      "question_text": "다음 중 C언어에서 변수명으로 사용할 수 있는 것은?",
      "options": [
        "8_dei",
        "while",
        "di sum",
        "iAvg"
      ],
      "examples": null,
      "answer_text": "iAvg",
      "comment_text": "보기 중 C언어에서 변수명으로 사용할 수 있는 것은 iAvg입니다. ① 변수명의 첫 글자로 숫자를 사용할 수 없습니다. ② 예약어는 변수명으로 사용할 수 없습니다. ③ 변수명 중간에 공백을 사용할 수 없습니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 37,
      "subject": 2,
      "question_text": "정보 보안의 3대 요소에 해당하지 않는 것은?",
      "options": [
        "휘발성",
        "기밀성",
        "무결성",
        "가용성"
      ],
      "examples": null,
      "answer_text": "휘발성",
      "comment_text": "소프트웨어 개발이 있어 충족시켜야 할 3대 주요 보안 요소에는 기밀성(Confidentiality), 무결성(Integrity), 가용성(Availability)이 있습니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 38,
      "subject": 2,
      "question_text": "C언어에서 정수 변수 a, b에 각각 1, 2가 저장되어 있을 때 다음 식의 연산 결과로 옳은 것은? a < b + 2 && a << 1 <= b",
      "options": [
        "0",
        "1",
        "2",
        "3"
      ],
      "examples": null,
      "answer_text": "1",
      "comment_text": "지문의 연산 결과는 1입니다. ·연산자의 우선순위는 높은 것부터 차례대로 단항, 산술, 시프트, 관계, 비트, 논리, 조건, 대입, 순서 연산자 순이며, 관계 연산자 중에서 <, <=, >=, >는 ==, !=보다 우선순위가 높습니다. ·우선순위에 따라 문제의 식을 풀면 다음과 같습니다. a < b + 2 && a << 1 <= b 1 3 2 4 5 ① b+2: b의 값은 2이므로 결과는 4이다. ② a<<1: 왼쪽 시프트(<<)는 왼쪽으로 1비트 시프트 할 때마다 2배씩 증가하므로, a의 값 1을 왼쪽으로 1비트 시프트한 결과는 2이다. ③ a<a<4: a의 값 1은 4보다 작으므로 결과는 1(참)이다. ④ 2<=b→ 2<=b : b의 값 2는 2와 같으므로 결과는 1(참)이다. ⑤ 1&&1: &&은 모두 참일 때만 참이므로 결과는 1(참)이다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 39,
      "subject": 2,
      "question_text": "특정 모듈에 대해서 존재하는 처리 요소들 간의 기능적 연관성을 의미하는 것으로 입력이나 에러 처리 같은 유사한 기능을 행하는 요소끼리 하나의 요소로 묶는 응집도는?",
      "options": [
        "기능적 응집도",
        "순차적 응집도",
        "논리적 응집도",
        "절차적 응집도"
      ],
      "examples": null,
      "answer_text": "논리적 응집도",
      "comment_text": "문제에서 설명하는 응집도는 논리적 응집도입니다. ·기능적 응집도(Functional Cohesion) : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도 ·순차적 응집도(Sequential Cohesion): 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도 ·절차적 응집도(Procedural Cohesion): 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 40,
      "subject": 2,
      "question_text": "스크립트 언어가 아닌 것은?",
      "options": [
        "PHP",
        "Cobol",
        "Basic",
        "Python"
      ],
      "examples": null,
      "answer_text": "Cobol",
      "comment_text": "Cobol은 절차적 프로그래밍 언어로 개발되었으나, 이후 객체 지향으로 변경된 컴파일 언어입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 41,
      "subject": 3,
      "question_text": "SQL의 데이터 조작문(DML)에 해당하는 것은?",
      "options": [
        "CREATE",
        "INSERT",
        "ALTER",
        "DROP"
      ],
      "examples": null,
      "answer_text": "INSERT",
      "comment_text": "INSERT는 데이터 조작어(DML)이고, CREATE, ALTER, DROP은 데이터 정의어(DDL)에 해당합니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 42,
      "subject": 3,
      "question_text": "다음 중 교차곱을 의미하는 기호는?",
      "options": [
        "∪",
        "∩",
        "-",
        "×"
      ],
      "examples": null,
      "answer_text": "×",
      "comment_text": "ㆍ교차곱을 의미하는 기호는 ×입니다. • U는 합집합, ∩는 교집합, -는 차집합을 의미하는 기호입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 43,
      "subject": 3,
      "question_text": "A→B 이고 B→C일 때 A → C를 만족하는 종속 관계를 제거하는 정규화 단계는?",
      "options": [
        "1NF → 2NF",
        "2NF → 3NF",
        "3NF → BCNF",
        "비정규 릴레이션 → 1NF"
      ],
      "examples": null,
      "answer_text": "2NF → 3NF",
      "comment_text": "A→B이고 B→C 일때 A→C를 만족하는 종속 관계는 이행적 종속 관계입니다. 이행적 종속 관계를 제거하는 단계는 2NF → 3NF입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 44,
      "subject": 3,
      "question_text": "데이터베이스에서 두 릴레이션을 합병할 때 사용하는 연산자는?",
      "options": [
        "집합 연산자",
        "관계 연산자",
        "비교 연산자",
        "논리 연산자"
      ],
      "examples": null,
      "answer_text": "집합 연산자",
      "comment_text": "데이터베이스에서 두 릴레이션을 합병할 때 사용하는 연산자입니다. ·관계(비교) 연산자 : 두 수의 관계를 비교하여 참(true) 또는 거짓(false)을 결과로 얻는 연산자 ·논리 연산자 : 두 개의 논리 값을 연산하여 참(true) 또는 거짓(false)을 결과로 얻는 연산자"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 45,
      "subject": 3,
      "question_text": "'학생' 테이블에서 3학년이고 컴퓨터공학과인 학생의 이름만 조회하는 SQL문으로 옳바른 것은?",
      "options": [
        "SELECT 이름 FROM 학생 WHERE 학년 = 3 AND 학과 = “컴퓨터공학”;",
        "SELECT 이름 FROM 학생 WHERE 학년 = 3 OR 학과 = “컴퓨터공학”;",
        "SELECT 이름 WHEN 학생 WHERE 학년 = 3 AND 학과 = “컴퓨터공학”;",
        "SELECT 이름 WHEN 학생 WHERE 학년 = 3 OR 학과 = “컴퓨터공학”;"
      ],
      "examples": null,
      "answer_text": "SELECT 이름 FROM 학생 WHERE 학년 = 3 AND 학과 = “컴퓨터공학”;",
      "comment_text": "문제의 내용으로 SQL문으로 작성하면 다음과 같습니다. ·'학생' 테이블에서 ‘이름'만 조회하므로 SELECT 이름 FROM 학생입니다. · ‘3학년'이고 ‘컴퓨터공학과'인 학생을 대상으로 하므로 WHERE 학년 = 3 AND 학과 = “컴퓨터공학”; 입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 46,
      "subject": 3,
      "question_text": "관계대수와 관계해석에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "기본적으로 관계대수와 관계해석은 관계 데이터베이스를 처리하는 기능과 능력면에서 동등하다.",
        "관계대수는 질의에 대한 해를 생성하기 위해 수행해야 할 연산의 순서를 명시하므로, 비절차적 특징을 가진다.",
        "관계해석은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특징을 가지고 있다.",
        "관계해석은 수학의 프레디킷 해석(Predicate Calculus)에 기반을 두고 있다."
      ],
      "examples": null,
      "answer_text": "관계대수는 질의에 대한 해를 생성하기 위해 수행해야 할 연산의 순서를 명시하므로, 비절차적 특징을 가진다.",
      "comment_text": "관계대수는 질의에 대한 해를 생성하기 위해 수행해야 할 연산의 순서를 명시하는 절차적 언어입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 47,
      "subject": 3,
      "question_text": "SQL 명령어 중 DDL에 해당하는 것은?",
      "options": [
        "SELECT",
        "UPDATE",
        "DELETE",
        "ALTER"
      ],
      "examples": null,
      "answer_text": "ALTER",
      "comment_text": "SELECT, UPDATE, DELETE는 DML(데이터 조작어)입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 48,
      "subject": 3,
      "question_text": "한 릴레이션의 기본키를 구성하는 어떠한 속성 값도 널(Null) 값이나 중복 값을 가질 수 없다는 것을 의미하는 것은?",
      "options": [
        "개체 무결성 제약 조건",
        "참조 무결성 제약 조건",
        "도메인 무결성 제약 조건",
        "키 무결성 제약 조건"
      ],
      "examples": null,
      "answer_text": "개체 무결성 제약 조건",
      "comment_text": "한 릴레이션의 기본키를 구성하는 어떠한 속성 값도 널(Null) 값이나 중복 값을 가질 수 없다는 것을 의미하는 것은 개체 무결성 제약 조건입니다. ·참조 무결성 : 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정임 · 도메인 무결성 : 주어진 속성 값이 정의된 도메인*에 속한 값이어야 한다는 규정임"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 49,
      "subject": 3,
      "question_text": "릴레이션을 조작할 때 데이터의 중복으로 인하여 발생하는 이상(Anomaly) 현상이 아닌 것은?",
      "options": [
        "검색 이상",
        "삽입 이상",
        "삭제 이상",
        "갱신 이상"
      ],
      "examples": null,
      "answer_text": "검색 이상",
      "comment_text": "이상의 종류에는 삽입 이상, 삭제 이상, 갱신 이상이 있습니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 50,
      "subject": 3,
      "question_text": "키는 개체 집합에서 고유하게 개체를 식별할 수 있는 속성이다. 데이터베이스에서 사용되는 키의 종류에 대한 설명 중 옳지 않은 것은?",
      "options": [
        "후보키는 개체들을 고유하게 식별할 수 있는 속성이다.",
        "슈퍼키는 한 릴레이션 내의 속성들의 집합으로 구성된 키이다.",
        "외래키는 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합이다.",
        "보조키는 후보키 중에서 대표로 선정된 키이다."
      ],
      "examples": null,
      "answer_text": "보조키는 후보키 중에서 대표로 선정된 키이다.",
      "comment_text": "보조키는 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보 키를 의미한다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 51,
      "subject": 3,
      "question_text": "SQL에서 VIEW를 삭제할 때 사용하는 명령은?",
      "options": [
        "ERASE",
        "KILL",
        "DROP",
        "DELETE"
      ],
      "examples": null,
      "answer_text": "DROP",
      "comment_text": "SQL에서 뷰(View)를 정의할 때 사용하는 명령은 CREATE, 삭제할 때 사용하는 명령은 DROP입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 52,
      "subject": 3,
      "question_text": "해싱에서 서로 다른 두 개 이상의 레코드가 동일한 주소를 갖는 현상을 의미하는 것은?",
      "options": [
        "Synonym",
        "Collision",
        "Bucket",
        "Slot"
      ],
      "examples": null,
      "answer_text": "Collision",
      "comment_text": "서로 다른 두 개 이상의 레코드가 같은 주소를 갖는 현상을 의미하는 것은 Collision(충돌 현상)입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 53,
      "subject": 3,
      "question_text": "시스템 카탈로그에 대한 설명으로 틀린 것은?",
      "options": [
        "시스템 자신이 필요로 하는 스키마 및 여러 가지 객체에 관한 정보를 포함하고 있는 시스템 데이터베이스이다.",
        "시스템 카탈로그에 저장되는 내용을 메타 데이터라고 한다.",
        "데이터 사전이라고도 한다.",
        "일반 사용자는 시스템 테이블의 내용을 검색할 수 없다."
      ],
      "examples": null,
      "answer_text": "일반 사용자는 시스템 테이블의 내용을 검색할 수 없다.",
      "comment_text": "시스템 카탈로그 자체도 테이블(시스템 테이블)로 구성되어 있어 일반 사용자도 SQL을 이용하여 내용을 검색해 볼 수 있습니다. 단, 수정은 불가능합니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 54,
      "subject": 3,
      "question_text": "버블 정렬을 이용한 오름차순 정렬시 다음 자료에 대한 3회전 후의 결과는? 9, 6, 7, 3, 5",
      "options": [
        "3, 5, 6, 7, 9",
        "6, 3, 5, 7, 9",
        "6, 7, 3, 5, 9",
        "9, 7, 6, 5, 3"
      ],
      "examples": null,
      "answer_text": "3, 5, 6, 7, 9",
      "comment_text": "버블 정렬은 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식으로 다음과 같은 과정으로 진행됩니다. ·초기상태 : 9, 6, 7, 3, 5 · 1회전 : 6,9, 7, 3, 5→ 6, 7, 9, 3, 5 → 6, 7, 3, 9, 5 → 6, 7, 3, 5, 9 • 2회전 : 6,7, 3, 5, 9 → 6, 3, 7, 5, 9 → 6, 3, 5, 7, 9 • 3회전 : 3,6, 5, 7, 9 → 3, 5, 6, 7, 9 • 4회전 : 3,5, 6, 7, 9"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 55,
      "subject": 3,
      "question_text": "데이터베이스에서 아직 알려지지 않거나 모르는 값으로서 “해당 없음” 등의 이유로 정보 부재를 나타내기 위해 사용하는 특수한 데이터 값을 무엇이라 하는가?",
      "options": [
        "원자값(Atomic Value)",
        "참조값(Reference Value)",
        "무결값(Integrity Value)",
        "널값(Null Value)"
      ],
      "examples": null,
      "answer_text": "널값(Null Value)",
      "comment_text": "데이터베이스에서 아직 알려지지 않거나 모르는 값으로서 “해당 없음” 등의 이유로 정보 부재를 나타내기 위해 사용하는 특수한 데이터 값을 무엇이라 하는가? 널 값(Null Value)이라고 합니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 56,
      "subject": 3,
      "question_text": "아래 SQL 문에서 WHERE 절의 조건이 의미하는 것은? SELECT 이름, 과목, 점수 FROM 학생 WHERE 이름 NOT LIKE '박__';",
      "options": [
        "'박'으로 시작되는 모든 문자 이름을 검색한다.",
        "'박'으로 시작하지 않는 모든 문자 이름을 검색한다.",
        "'박'으로 시작하는 3글자의 문자 이름을 검색한다.",
        "'박'으로 시작하지 않는 3글자의 문자 이름을 검색한다."
      ],
      "examples": null,
      "answer_text": "'박'으로 시작하지 않는 3글자의 문자 이름을 검색한다.",
      "comment_text": "WHERE절의 조건 중 NOT은 결과를 반대로 출력하는 논리 부정 연산자, LIKE는 지정된 문자를 포함하는 문자열을 찾는 연산자, _은 한 자리 문자를 대신하는 대표 문자입니다. • WHERE 절의 정확한 의미는 “박”으로 시작하지 않거나 박으로 시작하면서 3글자가 아닌 문자 이름을 검색한다.'이므로 보기 ④번의 내용은 여기에 포함된다고 할 수 있습니다. ·정리하자면 “박”으로 시작하지 않는 모든 이름을 검색한다. [예] 왕건, 김선길, 을지문덕 등 -“박”으로 시작하면서 3글자가 아닌 이름을 검색한다. [예] 박열, 박혁거세 등"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 57,
      "subject": 3,
      "question_text": "개체-관계 모델의 E-R 다이어그램에서 속성을 의미하는 그래픽 표현은?",
      "options": [
        "사각형",
        "타원",
        "마름모",
        "삼각형"
      ],
      "examples": null,
      "answer_text": "타원",
      "comment_text": "개체-관계 모델의 E-R 다이어그램에서 속성을 의미하는 그래픽 표현은 타원입니다. ·사각형 : 개체(Entity) 타입 ·마름모 : 관계(Relationship) 타입"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 58,
      "subject": 3,
      "question_text": "다음 질의문 실행의 결과는? SELECT 가격 FROM 도서가격 WHERE 책번호 = (SELECT 책번호 FROM 도서 WHERE 책명 = '운영체제'); <도서가격> <도서> 책번호 가격 책번호 책명 1111 15000 1111 운영체제 2222 23000 2222 세계지도 3333 7000 3333 생활영어 4444 5000",
      "options": [
        "5000",
        "7000",
        "15000",
        "23000"
      ],
      "examples": null,
      "answer_text": "15000",
      "comment_text": "질의문 실행의 결과는 15000입니다. 문제의 질의문은 하위 질의가 있는 질의문입니다. 먼저 WHERE 조건에 지정된 하위 질의의 SELECT문을 검색합니다. 그리고 검색 결과를 본 질의의 조건에 있는 '책번호' 속성과 비교합니다. ● SELECT 책번호 FROM 도서 WHERE 책명 = '운영체제' : <도서> 테이블에서 '책명' 속성의 값이 '운영체제'와 같은 튜플의 '책번호' 속성의 값을 검색합니다. 결과는 1111입니다. ● SELECT 가격 FROM 도서가격 WHERE 책번호 = 1111; : <도서가격> 테이블에서 ‘책번호' 속성의 값이 1111과 같은 튜플의 '가격' 속성의 값을 검색합니다. 결과는 15000입니다."
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 59,
      "subject": 3,
      "question_text": "다음에 해당하는 트랜잭션(ACID)의 특성은? 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다.",
      "options": [
        "Atomicity",
        "Consistency",
        "Isolation",
        "Durability"
      ],
      "examples": null,
      "answer_text": "Isolation",
      "comment_text": "둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다는 것을 의미하는 트랜잭션의 특징은 Isolation(독립성)입니다. ·Atomicity(원자성): 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 함 • Consistency(일관성) : 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함 ·Durability(영속성, 지속성) : 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함"
    },
    {
      "sourceKey": "2024-1",
      "sourceSessionId": "1",
      "problem_number": 60,
      "subject": 3,
      "question_text": "다음 설명이 의미하는 것은? ·삽입과 삭제가 리스트의 양쪽 끝에서 발생할 수 있는 형태이다. ·입력이 한쪽에서만 발생하고 출력은 양쪽에서 일어날 수 있는 입력 제한과 입력은 양쪽에서 일어나고 출력은 한 곳에서만 이루어지는 출력 제한이 있다.",
      "options": [
        "스택",
        "큐",
        "다중 스택",
        "데크"
      ],
      "examples": null,
      "answer_text": "데크",
      "comment_text": "삽입과 삭제가 리스트의 양쪽 끝에서 발생할 수 있는 자료 구조는 데크(Deque)입니다. ㆍ스택(Stack): 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조로, 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO; Last In First Out) 방식으로 자료를 처리함 ㆍ큐(Queue): 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조로, 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO; First In First Out) 방식으로 처리함"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 1,
      "subject": 1,
      "question_text": "행위 다이어그램의 종류 중 다음 설명에 해당하는 것은? • 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화 하는지를 표현한다. •럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델 링에 활용된다.",
      "options": [
        "상태 다이어그램(State Diagram)",
        "순차 다이어그램(Sequence Diagram)",
        "객체 다이어그램(Object Diagram)",
        "유스케이스 다이어그램(Use Case Diagram)"
      ],
      "examples": null,
      "answer_text": "상태 다이어그램(State Diagram)",
      "comment_text": "상태 다이어그램(State Diagram)에 대한 설명입니다. ·순차 다이어그램(Sequence Diagram) : 상호 작용하는 시 스템이나 객체들이 주고받는 메시지를 표현 ·객체 다이어그램(Object Diagram) : 클래스에 속한 사물 (객체)들, 즉 인스턴스(Instance)를 특정 시점의 객체와 객 체 사이의 관계로 표현 ·유스케이스 다이어그램(Use Case Diagram) : 사용자의 요 구를 분석하는 것으로 기능 모델링 작업에 사용함"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 2,
      "subject": 1,
      "question_text": "애자일 개발 방법론에 해당하지 않는 것은?",
      "options": [
        "기능 주도 개발(FDD, Feature Driven Development)",
        "하둡(Hadoop)",
        "스크럼(Scrum)",
        "익스트림 프로그래밍(XP, eXtreme Programming)"
      ],
      "examples": null,
      "answer_text": "하둡(Hadoop)",
      "comment_text": "하둡(Hadoop)은 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫 폼으로, 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형 성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발된 자바 소프트웨어 프레임워크입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 3,
      "subject": 1,
      "question_text": "다이어그램에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "활동 다이어그램(Activity Diagram) : 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현한다.",
        "시퀀스 다이어그램(Sequence Diagram) : 상호 작용하는 시스 템이나 객체들이 주고받는 메시지를 표현한다.",
        "유스케이스 다이어그램(Use Case Diagram) : 사용자의 요구 를 분석하는 것으로 기능 모델링 작업에 사용한다.",
        "객체 다이어그램(Object Diagram): 클래스와 클래스가 가지 는 속성, 클래스 사이의 관계를 표현한다."
      ],
      "examples": null,
      "answer_text": "객체 다이어그램(Object Diagram): 클래스와 클래스가 가지 는 속성, 클래스 사이의 관계를 표현한다.",
      "comment_text": "객체 다이어그램(Object Diagram)은 클래스에 속한 사물 (객체)들, 즉 인스턴스(Instance)를 특정 시점의 객체와 객 체 사이의 관계로 표현합니다. •4번은 클래스 다이어그램(Class Diagram)에 대한 설명입 니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 4,
      "subject": 1,
      "question_text": "다음 검사의 기법 중 종류가 다른 하나는 무엇인가?",
      "options": [
        "원인 효과 그래픽 기법(Cause-effect Graphingtesting)",
        "동치 분할 검사(Equivalence Partitioning Testing)",
        "데이터 흐름 검사(Data Flow Testing)",
        "비교 검사(Comparison Testing)"
      ],
      "examples": null,
      "answer_text": "데이터 흐름 검사(Data Flow Testing)",
      "comment_text": "데이터 흐름 검사는 화이트박스 테스트의 종류이고, 나머지는 블랙박스 테스트의 종류입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 5,
      "subject": 1,
      "question_text": "개발 단계에 따른 애플리케이션 테스트에 속하지 않는 것은?",
      "options": [
        "통합 테스트",
        "단위 테스트",
        "구조 테스트",
        "인수 테스트"
      ],
      "examples": null,
      "answer_text": "구조 테스트",
      "comment_text": "애플리케이션 테스트는 소프트웨어의 개발 단계에 따라 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트로 분류됩니 다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 6,
      "subject": 1,
      "question_text": "다음 표와 같이 작업이 제출되었다. 이를 FIFO 정책으로 스케줄링하면 평균 반환 시간은 얼마인가?",
      "options": [
        "3",
        "4",
        "7.2",
        "9.4"
      ],
      "examples": "프로세스|도착시간|실행시간\nP1|0|3\nP2|1|7\nP3|3|2\nP4|5|5\nP5|6|3",
      "answer_text": "9.4",
      "comment_text": "FIFO는 준비상태 큐에 도착한 순서대로 작업을 수행하므로, 다음과 같은 순서로 수행됩니다. 진행 시간 0 0 3 3 도착실행 완료 P1 실행 시작 P2 1 2 3 도착대기 실행 10 7 실행 10 완료 시작 2 실행 3 P3 7 도착 대기 10 12 실행 완료 시작 17 5 P4 7 12 5 도착 대기 실행 실행 완료 시작 P5 6 11 도착 대기 17 3 20 20 실행 실행 완료 시작 평균 반환 시간은 (3+9+9+12+14)/5 = 9.4 시간이 됩니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 7,
      "subject": 1,
      "question_text": "Process의 3가지 상태에 해당하지 않는 것은?",
      "options": [
        "Ready",
        "Block",
        "Running",
        "Indexing"
      ],
      "examples": null,
      "answer_text": "Indexing",
      "comment_text": "프로세스(Process)의 주요 3가지 상태는 준비(Ready), 실행 (Running), 대기(Wait, Block)입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 8,
      "subject": 1,
      "question_text": "네트워크 관련 신기술에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "SSO: 하나의 시스템에서 인증에 성공하면 다른 시스템에 대한 접근 권한도 얻는 시스템이다.",
        "PICONET: 여러 개의 독립된 통신장치가 UWB 기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술이다.",
        "PaaS-TA: 전기의 생산부터 소비까지의 전 과정에 정보통신 기술을 접목하여 에너지 효율성을 높이는 지능형 전력망 시스 템이다.",
        "Mesh Network : 차세대 이동통신, 홈네트워킹, 공공안전 등의 특수 목적에 사용되는 새로운 방식의 네트워크 기술이다."
      ],
      "examples": null,
      "answer_text": "PaaS-TA: 전기의 생산부터 소비까지의 전 과정에 정보통신 기술을 접목하여 에너지 효율성을 높이는 지능형 전력망 시스 템이다.",
      "comment_text": "파스-타(PaaS-TA)는 소프트웨어 개발 환경을 제공하기 위해 개발한 개방형 클라우드 컴퓨팅 플랫폼으로, 국내 IT 서비스 경쟁력 강화를 목표로 과학기술정보통신부와 한국 정보화진흥원이 연구개발(R&D)을 지원하였습니다. •③번은 스마트 그리드(Smart Grid)에 대한 설명입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 9,
      "subject": 1,
      "question_text": "공통된 속성과 연산을 갖는 객체의 집합으로, 객체의 일반적인 타입(Type)을 의미하는 것은?",
      "options": [
        "객체(Object)",
        "클래스(Class)",
        "캡슐화(Encapsulation)",
        "상속(Inheritance)"
      ],
      "examples": null,
      "answer_text": "클래스(Class)",
      "comment_text": "공통된 속성과 연산을 갖는 객체의 집합으로, 객체의 일반적 인 타입(Type)을 클래스(Class)라고 합니다. ·객체(Object) : 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈 ·캡슐화(Encapsulation) : 데이터(속성)와 데이터를 처리하 는 함수를 하나로 묶는 것을 의미함 ·상속(Inheritance): 이미 정의된 상위 클래스(부모 클래스) 의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받 는 것"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 10,
      "subject": 1,
      "question_text": "다음 괄호에 들어갈 알맞은 용어는? ()는 구체 클래스에서 구현하려는 기능들의 공통점만 을 모은 것으로, 인스턴스 생성이 불가능하여 구체 클래 스가( )를 상속받아 구체화한 후 구체 클래스의 인스 턴스를 생성하는 방식으로 사용한다.",
      "options": [
        "서브 클래스",
        "제어 클래스",
        "추상 클래스",
        "조상 클래스"
      ],
      "examples": null,
      "answer_text": "추상 클래스",
      "comment_text": "문제의 지문에 제시된 내용은 추상 클래스에 대한 설명입니 다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 11,
      "subject": 1,
      "question_text": "모듈 결합도의 종류 중 스탬프 결합도(Stamp Coupling)에 대한 설명으로 틀린 것은?",
      "options": [
        "모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도이다.",
        "결합의 정도가 자료 결합도보다 강하고, 제어 결합도보다 약하다.",
        "두 모듈이 동일한 자료 구조를 조회하는 경우의 결합도이다.",
        "자료 구조의 변화가 다른 모듈에 영향을 끼치지 않는다."
      ],
      "examples": null,
      "answer_text": "자료 구조의 변화가 다른 모듈에 영향을 끼치지 않는다.",
      "comment_text": "스탬프 결합도에서 자료 구조의 변화는 그것을 조회하는 모든 모듈은 물론, 실제로 조회하지 않는 모듈에 까지 영향을 미칩 니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 12,
      "subject": 1,
      "question_text": "디스크 대기 큐에 다음과 같은 순서(왼쪽부터 먼저 도착한 순서임)로 트랙의 액세스 요청이 대기 중이다. 모든 트랙을 서비스하기 위하여 FCFS 스케줄링 기법이 사용될 때, 모두 몇 트랙의 헤드 이동이 생기는가? (단, 현재 헤드의 위치는 50 트랙이다.) 디스크 대기 큐: 10, 40, 55, 35",
      "options": [
        "50",
        "85",
        "105",
        "110"
      ],
      "examples": null,
      "answer_text": "105",
      "comment_text": "FCFS 스케줄링 기법은 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법이고 현재 헤드의 위치가 50 트 랙이므로 이동 순서는 '50 → 10 → 40→55 → 35' 순으로 진행됩니다. 그러므로 총 이동거리는 40 + 30 + 15 + 20 = 105입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 13,
      "subject": 1,
      "question_text": "데이터 전송에서 한 문자의 전송 시마다 스타트 비트와 스톱 비트를 삽입하여 전송하는 방식은?",
      "options": [
        "동기식",
        "비동기식",
        "베이스밴드식",
        "혼합 동기식"
      ],
      "examples": null,
      "answer_text": "비동기식",
      "comment_text": "데이터 전송에서 한 문자의 전송 시마다 스타트 비트와 스톱 비트를 삽입하여 전송하는 방식은 비동기식 전송 방식입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 14,
      "subject": 1,
      "question_text": "객체 지향 기법에서 객체가 메시지를 받아 실행해야 할 때 객체의 구체적인 연산을 정의한 것은?",
      "options": [
        "Instance",
        "Method",
        "Message",
        "Class"
      ],
      "examples": null,
      "answer_text": "Method",
      "comment_text": "객체 지향 기법에서 객체가 메시지를 받아 실행해야 할 때 객체의 구체적인 연산을 정의한 것은 메소드(Method)입니다. · 인스턴스(Instance) : 하나의 클래스에 속하는 각각의 객체 ·메시지(Message) : 외부로부터 하나의 객체에 전달되는 메 소드(행위)의 요구 ·클래스(Class) : 두 개 이상의 유사한 객체들을 묶어서 하나 의 공통된 특성을 표현하는 요소"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 15,
      "subject": 1,
      "question_text": "개체-관계(E-R) 모델에서 개체 타입을 표시하는 기호는?",
      "options": [
        "◇ 마름모",
        "○ 타원",
        "□ 사각형",
        "▷ 삼각형"
      ],
      "examples": null,
      "answer_text": "□ 사각형",
      "comment_text": "개체 타입은 사각형으로 표시합니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 16,
      "subject": 1,
      "question_text": "오픈 소스 기반 분산 컴퓨팅 플랫폼인 아파치 하둡(Apache Hadoop) 기반의 분산 데이터 웨어하우스 프로젝트를 의미하는 것은?",
      "options": [
        "데이터 마이닝(Data Mining)",
        "맵리듀스(MapReduce)",
        "스쿱(Sqoop)",
        "타조(Tajo)"
      ],
      "examples": null,
      "answer_text": "타조(Tajo)",
      "comment_text": "아파치 하둡 기반의 분산 데이터 웨어하우스 프로젝트를 타조 (Tajo)라고 합니다. · 데이터 마이닝(Data Mining) : 데이터 웨어하우스에 저장된 데이터 집합에서 사용자의 요구에 따라 유용하고 가능성 있는 정보를 발견하기 위한 기법으로, 대량의 데이터를 분 석하여 데이터 속에 내재되어 있는 변수 사이의 상호관계를 규명하여 패턴화함으로써 효율적인 데이터 추출이 가능함 ·맵리듀스(MapReduce) : 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델로, 흩어져 있는 데 이터를 연관성 있는 데이터 분류로 묶는 Map 작업을 수행한 후 중복 데이터를 제거하고 원하는 데이터를 추출하는 Reduce 직업을 수행함 ㆍ스쿱(Sqoop): 하둡과 관계형 데이터베이스 사이에서 효율 적으로 데이터를 이관하고 변환해 주는 명령줄 인터페이스 애플리케이션"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 17,
      "subject": 1,
      "question_text": "기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 디자인 패턴은?",
      "options": [
        "브리지(Bridge)",
        "데코레이터(Decorator)",
        "어댑터(Adapter)",
        "퍼싸드(Facade)"
      ],
      "examples": null,
      "answer_text": "어댑터(Adapter)",
      "comment_text": "문제에 제시된 내용은 어댑터(Adapter) 패턴에 대한 설명입 니다. ·브리지(Bridge): 구현부에서 추상층을 분리하여, 서로 가 독립적으로 확장할 수 있도록 구성한 패턴 · 데코레이터(Decorator) : 객체 간의 결합을 통해 능동적 으로 기능들을 확장할 수 있는 패턴 ·퍼싸드(Facade) : 복잡한 서브 클래스들을 피해 더 상위 에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 18,
      "subject": 1,
      "question_text": "OSI 7계층 중 종점 호스트 사이의 데이터 전송을 다루는 계층으로 종점 간의 연결 관리, 오류제어와 흐름제어 등을 수행하는 계층은?",
      "options": [
        "물리 계층",
        "프레젠테이션 계층",
        "응용 계층",
        "전송 계층"
      ],
      "examples": null,
      "answer_text": "전송 계층",
      "comment_text": "종점 호스트 사이의 데이터 전송을 다루는 계층으로 종점 간의 연결 관리, 오류제어와 흐름제어 등을 수행하는 계층은 전송 계층(Transport Layer)입니다. ·물리 계층(Physical Layer) : 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의함(RS-232C, X.21 등) · 표현 계층(Presentation Layer) : 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능을 함 ·응용 계층(Application Layer) : 사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스를 제공함(SMTP, FTP, TELNET 등)"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 19,
      "subject": 1,
      "question_text": "HIPO의 3가지 패키지가 아닌 것은?",
      "options": [
        "도식목차(Visual Table of Contents)",
        "순서도(Flowchart)",
        "총괄도표(Overview Diagram)",
        "상세도표(Detail Diagram)"
      ],
      "examples": null,
      "answer_text": "순서도(Flowchart)",
      "comment_text": "HIPO의 3가지 패키지에는 가시적 도표(도식 목차), 총체적 도표(총괄 도표, 개요 도표), 세부적 도표(상세 도표)가 있습니 다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 20,
      "subject": 1,
      "question_text": "형상 관리(SCM)에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "형상 관리는 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하는 것이다.",
        "형상 관리의 기능에는 형상 식별, 버전 제어, 형상 통제 등이 있다.",
        "형상 관리의 관리 항목에는 프로젝트 개발 비용, 프로젝트 요구 분석서 등이 있다.",
        "대표적인 형상 관리 도구에는 Git, CVS, Subversion 등이 있 다."
      ],
      "examples": null,
      "answer_text": "형상 관리의 관리 항목에는 프로젝트 개발 비용, 프로젝트 요구 분석서 등이 있다.",
      "comment_text": "프로젝트 개발 비용은 소프트웨어 형상 관리의 관리 항목에 포함되지 않습니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 21,
      "subject": 2,
      "question_text": "프레임워크(Framework)의 특성과 가장 거리가 먼 것은?",
      "options": [
        "모듈화(Modularity)",
        "인증(Authentication)",
        "재사용성(Reusability)",
        "확장성(Extensibility)"
      ],
      "examples": null,
      "answer_text": "인증(Authentication)",
      "comment_text": "프레임워크의 특성에는 모듈화, 재사용성, 확장성, 제어의 역 흐름 등이 있습니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 22,
      "subject": 2,
      "question_text": "프레임워크의 특성에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "프레임워크는 재사용 가능한 모듈들을 제공함으로써 예산 절 감, 생산성 향상, 품질 보증이 가능하다.",
        "프레임워크는 다형성을 통한 인터페이스 확장이 가능하여 다 양한 형태와 기능을 가진 애플리케이션 개발이 가능하다.",
        "프레임워크는 개발표준에 의한 모듈화로 인해 유지 보수가 어 렵다.",
        "개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워 크에 넘김으로써 생산성을 향상시킨다."
      ],
      "examples": null,
      "answer_text": "프레임워크는 개발표준에 의한 모듈화로 인해 유지 보수가 어 렵다.",
      "comment_text": "프레임워크는 개발표준에 의한 모듈화로 인해 유지 보수가 용이합니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 23,
      "subject": 2,
      "question_text": "Module의 독립성을 높이려면 Coupling과 Cohesion은 어떤 관계가 되어야 하는가?",
      "options": [
        "Coupling과 Cohesion 모두 약해야 한다.",
        "Coupling과 Cohesion 모두 강해야 한다.",
        "Coupling은 강하고 Cohesion은 약해야 한다.",
        "Coupling은 약하고 Cohesion은 강해야 한다."
      ],
      "examples": null,
      "answer_text": "Coupling은 약하고 Cohesion은 강해야 한다.",
      "comment_text": "모듈(Module)의 독립성을 높이려면 결합도(Coupling)는 약 하게, 응집도(Cohesion)는 강하게 해야 합니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 24,
      "subject": 2,
      "question_text": "다음 Java 프로그램이 실행되었을 때, 실행 결과는? public class Test { public static void main(String[] args) { int n = 17; n += 1; n -= 2; n *= 3; n /= 4; n%= 5; System.out.println(n); } }",
      "options": [
        "1",
        "2",
        "3",
        "4"
      ],
      "examples": null,
      "answer_text": "2",
      "comment_text": "사용된 코드의 의미는 다음과 같습니다. public class Test { public static void main(String[] args) { int n = 17; n += 1; n -= 2; n *= 3; n /= 4; n%= 5; System.out.println(n); } } ● 정수형 변수 n을 선언하고 17로 초기화한다. (n=17) ② 'n = n + 1;'과 동일하다. n에 1을 더한 값을 n에 저장한다. (n=18) ③ 'n = n - 2;'와 동일하다. n에서 2를 뺀 값을 n에 저장한다. (n=16) ④ 'n = n * 3;'과 동일하다. n에 3을 곱한 값을 n에 저장한다. (n=48) ⑤ 'n = n / 4;'와 동일하다. n을 4로 나눈 값을 n에 저장한다. (n=12) ⑥ 'n = n % 5;'과 동일하다. n을 5로 나눈 나머지를 n에 저장 한다. (n=2) ● n의 값을 출력한 후 커서를 다음 줄의 처음으로 옮긴다. 결과 2"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 25,
      "subject": 2,
      "question_text": "조건이 참인지 거짓인지 판단하고자 할 때 사용하는 데이터 타입은?",
      "options": [
        "Integer Type",
        "Boolean Type",
        "Character String Type",
        "Floating Point Type"
      ],
      "examples": null,
      "answer_text": "Boolean Type",
      "comment_text": "조건이 참인지 거짓인지 판단하고자 할 때 사용하는 데이터 타입은 불린 타입(Boolean Type)입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 26,
      "subject": 2,
      "question_text": "캡슐화, 추상화, 상속성 등의 특징을 갖는 객체지향 언어는?",
      "options": [
        "C",
        "C++",
        "COBOL",
        "FORTRAN"
      ],
      "examples": null,
      "answer_text": "C++",
      "comment_text": "보기 중 객체지향 언어는 C++ 입니다. •C, COBOL, FORTRAN은 절차적 프로그래밍 언어에 속합 니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 27,
      "subject": 2,
      "question_text": "공통 모듈에 대한 명세 기법 중 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성하는 원칙은?",
      "options": [
        "추적성",
        "명확성",
        "완전성",
        "일관성"
      ],
      "examples": null,
      "answer_text": "추적성",
      "comment_text": "기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악 할 수 있도록 작성하는 원칙은 추적성(Traceability)입니다. ·정확성 : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성해야 한다는 원칙 ·명확성 : 해당 기능을 이해할 때 중의적으로 해석되지 않도 록 명확하게 작성해야 한다는 원칙 완전성 : 시스템 구현을 위해 필요한 모든 것을 기술해야 한다는 원칙"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 28,
      "subject": 2,
      "question_text": "다음 C 언어의 함수 중 인수로 주어진 한 문자를 화면에 출력하는 함수는?",
      "options": [
        "gets()",
        "getchar()",
        "puts()",
        "putchar()"
      ],
      "examples": null,
      "answer_text": "putchar()",
      "comment_text": "인수로 주어진 한 문자를 화면에 출력하는 함수는 putchar() 입니다. gets(): 키보드로 문자열을 입력받아 변수에 저장하는 함 수로, [Enter]를 누르기 전까지를 하나의 문자열로 인식하 여 저장함 ·getchar(): 키보드로 한 문자를 입력받아 변수에 저장하는 함수 ·puts(): 인수로 주어진 문자열을 화면에 출력한 후 커서를 자동으로 다음 줄 앞으로 이동하는 함수"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 29,
      "subject": 2,
      "question_text": "파일 포인터 변수가 가리키는 위치에서 데이터를 가져와 변수에 저장하는 함수는?",
      "options": [
        "fscanf",
        "fprintf",
        "fopen",
        "fclose"
      ],
      "examples": null,
      "answer_text": "fscanf",
      "comment_text": "파일 포인터 변수가 가리키는 위치에서 데이터를 가져와 변수 에 저장하는 함수는 fscanf입니다. ·fprintf: 파일 포인터 변수가 가리키는 위치에 변수에 저장 된 데이터를 출력하는 함수 ·fopen: 파일을 메모리에 저장한 후 그 시작 주소를 반환하 는 함수 · fclose: 파일 포인터 변수가 사용중인 메모리를 해제하는 함수"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 30,
      "subject": 2,
      "question_text": "다음 중 빌드 도구가 아닌 것은?",
      "options": [
        "Zeplin",
        "Ant",
        "Maven",
        "Gradle"
      ],
      "examples": null,
      "answer_text": "Zeplin",
      "comment_text": "Zeplin은 디자인 관련 협업 도구입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 31,
      "subject": 2,
      "question_text": "객체지향 프로그래밍 언어에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "추상화(Abstraction)는 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것이다.",
        "클래스(Class)는 두 개 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현하는 요소이다.",
        "캡슐화(Encapsulation)는 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미한다.",
        "객체(Object)는 데이터(속성)와 이를 처리하기 위한 연산(메소 드)을 결합시킨 실체이다."
      ],
      "examples": null,
      "answer_text": "추상화(Abstraction)는 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것이다.",
      "comment_text": "추상화는 불필요한 부분을 생략하고 객체의 속성 중 가장 중요 한 것에만 중점을 두어 개략화하는 것, 즉 모델화하는 것입니 다. •①번은 정보 은닉(Information Hiding)에 대한 설명입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 32,
      "subject": 2,
      "question_text": "웹 서버(Web Server)의 기능 중 하나로, 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능을 무엇이라 하는가?",
      "options": [
        "HTTP/HTTPS",
        "정적 파일 관리",
        "대역폭 제한",
        "가상 호스팅"
      ],
      "examples": null,
      "answer_text": "대역폭 제한",
      "comment_text": "문제에 제시된 내용은 대역폭 제한의 기능입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 33,
      "subject": 2,
      "question_text": "다음은 Java로 만들어진 반복문 코드이다. 이 코드의 결과는? ..생략.. int a = 0, sum = 0; do { a++; sum += a; } while(a > 10); ..생략..",
      "options": [
        "a = 0, sum = 0",
        "a = 1, sum = 1",
        "a = 9, sum = 45",
        "a = 10, sum = 55"
      ],
      "examples": null,
      "answer_text": "a = 1, sum = 1",
      "comment_text": "정수형 변수 a와 sum을 선언하고 0으로 초기화합니다. (a=0, sum=0) ② do~while문의 시작이다. 3~4번을 반복 수행합니다. ③ 'a = a + 1;'과 동일하다. a에 1을 더한다. (a=1) 4 'sum = sum + a;'와 동일하다. sum에 a의 값을 더합니다. (sum=1) ⑤ a가 10보다 큰 동안 3~4번을 반복 수행한다. a가 10보다 크지 않으므로 반복문을 벗어납니다. (a=1, sum=1)"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 34,
      "subject": 2,
      "question_text": "일련의 처리 절차를 정해진 문법에 따라 순서대로 기술해 나가 는 언어는?",
      "options": [
        "객체 지향 프로그래밍 언어",
        "스크립트 언어",
        "구조적 프로그래밍 언어",
        "절차적 프로그래밍 언어"
      ],
      "examples": null,
      "answer_text": "절차적 프로그래밍 언어",
      "comment_text": "일련의 처리 절차를 정해진 문법에 따라 순서대로 기술해 나가 는 언어는 절차적 프로그래밍 언어입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 35,
      "subject": 2,
      "question_text": "다음 중 스크립트 언어에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "개발 시간이 짧다.",
        "코딩하기 쉽다.",
        "런타임 오류가 많이 발생한다.",
        "실행 속도가 빠르다."
      ],
      "examples": null,
      "answer_text": "실행 속도가 빠르다.",
      "comment_text": "스크립트 언어는 코드를 읽고 해석해야 하므로 실행 속도가 느립니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 36,
      "subject": 2,
      "question_text": "다음 중 C언어의 변수명 작성에 대한 설명으로 가장 옳지 않은 것은?",
      "options": [
        "대소문자를 구분하지 않는다.",
        "영문, 숫자, 언더바 등을 사용할 수 있다.",
        "글자 수에 제한이 없다.",
        "예약어는 변수명으로 사용할 수 없다"
      ],
      "examples": null,
      "answer_text": "대소문자를 구분하지 않는다.",
      "comment_text": "C언어에서 변수명은 대·소문자를 구분합니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 37,
      "subject": 2,
      "question_text": "기억 클래스(Storage Class)의 종류 중 함수나 코드의 범위를 한정하 는 블록 내에서 선언되는 변수는?",
      "options": [
        "외부 변수(External Variable)",
        "정적 변수(Static Variable)",
        "자동 변수(Automatic Variable)",
        "레지스터 변수(Register Variable)"
      ],
      "examples": null,
      "answer_text": "자동 변수(Automatic Variable)",
      "comment_text": "함수나 코드의 범위를 한정하는 블록 내에서 선언되는 변수는 자동 변수(Automatic Variable)입니다. · 외부 변수(External Variable) : 현재 파일이나 다른 파일에 서 선언된 변수나 함수를 참조(reference)하기 위한 변수 ·정적 변수(Static Variable) : 함수나 블록 내에서 선언되어 선언한 함수나 블록 내에서만 사용할 수 있는 내부 정적 변 수와, 함수 외부에서 선언되어 모든 함수에서 사용할 수 있 는 외부 정적 변수가 있음 · 레지스터 변수(Register Variable) : 자주 사용되는 변수의 처리속도를 높이기 위해 사용하는 기억 클래스로, 메모리가 아닌 CPU 내부의 저장장소를 기억영역으로 할당받는 변수"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 38,
      "subject": 2,
      "question_text": "C 언어 라이브러리 중 stdlib.h에 대한 설명으로 옳은 것은?",
      "options": [
        "문자열을 수치 데이터로 바꾸는 문자 변환함수와 수치를 문자 열로 바꿔주는 변환함수 등이 있다.",
        "문자열 처리 함수로 strlen()이 포함되어 있다.",
        "표준 입출력 라이브러리이다.",
        "삼각 함수, 제곱근, 지수 등 수학적인 함수를 내장하고 있다."
      ],
      "examples": null,
      "answer_text": "문자열을 수치 데이터로 바꾸는 문자 변환함수와 수치를 문자 열로 바꿔주는 변환함수 등이 있다.",
      "comment_text": "stdlib.h에 대한 설명으로 옳은 것은 ①번입니다. ·②번은 string.h, ③ stdio.h, ④번은 math.h에 대한 설명입 니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 39,
      "subject": 2,
      "question_text": "N-S(Nassi-Schneiderman) chart에 대한 설명으로 거리가 먼 것은?",
      "options": [
        "논리의 기술에 중점을 둔 도형식 표현 방법이다.",
        "연속, 선택 및 다중 선택, 반복 등의 제어논리 구조로 표현한다.",
        "주로 화살표를 사용하여 논리적인 제어구조로 흐름을 표현한 다.",
        "조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하 는데 적합하다."
      ],
      "examples": null,
      "answer_text": "주로 화살표를 사용하여 논리적인 제어구조로 흐름을 표현한 다.",
      "comment_text": "화살표를 사용하여 논리적인 제어구조로 흐름을 표현하는 표 기법은 흐름도(Flowchart)입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 40,
      "subject": 2,
      "question_text": "다음 Java 프로그램이 실행되었을 때의 결과는? public class Test { public static void main(String[] args) { int x = 7, y = 0; while (x-- > 0) { if (x % 3 == 0) continue; y++; } System.out.print(y); } }",
      "options": [
        "0",
        "4",
        "5",
        "7"
      ],
      "examples": null,
      "answer_text": "4",
      "comment_text": "while 루프에서 x는 7부터 감소한다. x가 6, 3, 0일 때는 continue로 y 증가를 건너뛴다. 나머지 값(5, 4, 2, 1)에서만 y++가 수행되어 최종 y는 4가 된다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 41,
      "subject": 3,
      "question_text": "자료가 다음과 같을 때, 삽입(Insertion) 정렬 방법을 적용하여 오름차 순으로 정렬할 경우 Pass 2를 수행한 결과는? 자료: 8, 3, 4, 9, 7",
      "options": [
        "3, 8, 4, 9, 7",
        "3, 4, 8, 9, 7",
        "3, 4, 7, 9, 8",
        "3, 4, 7, 8, 9"
      ],
      "examples": null,
      "answer_text": "3, 4, 8, 9, 7",
      "comment_text": "삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들 과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘입니다. 즉 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾습니다. 초기 자료 : 83497 ● 1회전 : 83497 38497 → 두 번째 값 3을 첫 번째 값과 비교하여 첫 번째 자리에 삽입하고 8을 한 칸 뒤로 이동시킵니다. ② 2회전 : 38497 34897 ← 세 번째 값 4를 첫 번째, 두 번째 값과 비교하여 8자리에 삽입하고 8을 한 칸 뒤로 이동시킵니다. ③ 3회전 : 34897 → 34897 네 번째 값 9를 첫 번째, 두 번째, 세 번째 값과 비교합니다. 자리의 이동이 없습니다. ④ 4회전 : 34897 34789 → 다섯 번째 값 7을 처음부터 비교하여 8자리에 삽입하고 나머지를 한 칸씩 뒤로 이동시킵니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 42,
      "subject": 3,
      "question_text": "스택에 데이터를 A, B, C, D 순으로 저장했을 경우, 이들 데이터가 출력되는 결과로 가능한 것은?",
      "options": [
        "D, B, C, A",
        "C, B, D, A",
        "C, D, A, B",
        "D, A, C, B"
      ],
      "examples": null,
      "answer_text": "C, B, D, A",
      "comment_text": "이 문제는 문제의 자료가 각 보기의 순서대로 출력되는지 스택 을 이용해 직접 입·출력을 수행해 보면 됩니다. PUSH는 스 택에 자료를 입력하는 명령이고, POP는 스택에서 자료를 출 력하는 명령입니다. 먼저 ②번을 살펴볼게요. PUSH A PUSH B PUSH C POP C POP B PUSH D POP D 니다. POP A B C B B A A A A A D A A C CB CBD CBDA"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 43,
      "subject": 3,
      "question_text": "데이터베이스 설계 단계 중 논리적 설계 단계에 해당하는 것은?",
      "options": [
        "개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리 적 스키마를 설계한다.",
        "데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다.",
        "물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정이다.",
        "저장 레코드의 형식, 순서, 접근 경로 등의 정보가 컴퓨터에 저장되는 방법을 묘사한다."
      ],
      "examples": null,
      "answer_text": "개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리 적 스키마를 설계한다.",
      "comment_text": "②,③,④번은 물리적 설계 단계에서 수행하는 작업입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 44,
      "subject": 3,
      "question_text": "데이터베이스 설계 단계 중 가장 먼저 수행되는 것은?",
      "options": [
        "논리적 설계 단계",
        "개념적 설계 단계",
        "물리적 설계 단계",
        "요구 조건 분석 단계"
      ],
      "examples": null,
      "answer_text": "요구 조건 분석 단계",
      "comment_text": "데이터베이스 설계 단계를 순서대로 나열하면 '요구 조건 분 석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현'입니 다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 45,
      "subject": 3,
      "question_text": "DBMS의 필수 기능에 해당하지 않는 것은?",
      "options": [
        "정의 기능(Definition Facility)",
        "조작 기능(Manipulation Facility)",
        "제어 기능(Control Facility)",
        "회복 기능(Recovery Facility)"
      ],
      "examples": null,
      "answer_text": "회복 기능(Recovery Facility)",
      "comment_text": "DBMS의 필수 기능에는 정의 기능(Definition Facility), 조작 기능(Manipulation Facility), 제어 기능(Control Facility)이 있습니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 46,
      "subject": 3,
      "question_text": "일반적인 데이터 모델의 3가지 구성 요소로 옳은 것은?",
      "options": [
        "구조, 연산, 도메인",
        "데이터사전, 연산, 릴레이션",
        "구조, 연산, 제약조건",
        "릴레이션, 구조, 스키마"
      ],
      "examples": null,
      "answer_text": "구조, 연산, 제약조건",
      "comment_text": "일반적인 데이터 모델의 3가지 구성 요소는 구조, 연산, 제약 조건입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 47,
      "subject": 3,
      "question_text": "JOIN 조건에 '=' 조건이 아닌 나머지 비교 연산자를 사용하는 JOIN 방법은?",
      "options": [
        "EQUI JOIN",
        "NON-EQUI JOIN",
        "SELF JOIN",
        "CROSS JOIN"
      ],
      "examples": null,
      "answer_text": "NON-EQUI JOIN",
      "comment_text": "JOIN 조건에 '=' 조건이 아닌 나머지 비교 연산자를 사용하는 JOIN은 NON-EQUI JOIN입니다. • EQUI JOIN: JOIN 대상 테이블에서 공통 속성을 기준으로 '='(equal) 비교에 의해 같은 값을 가지는 행을 연결하여 결과를 생성하는 JOIN 방법 • SELF JOIN: 같은 테이블에서 2개의 속성을 연결하여 EQUI JOIN을 하는 JOIN 방법 ·CROSS JOIN(교차 조인) : 조인하는 두 테이블에 있는 튜플 들의 순서쌍을 결과로 반환하는 JOIN으로, 교차 조인의 결 과로 반환되는 테이블의 행의 수는 두 테이블의 행 수를 곱 한 것과 같음"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 48,
      "subject": 3,
      "question_text": "관계 데이터 모델에서 릴레이션의 특성으로 옳지 않은 것은?",
      "options": [
        "한 릴레이션에는 똑같은 튜플이 중복 포함될 수 있다.",
        "한 릴레이션에 포함된 튜플 사이에는 순서가 없다.",
        "한 릴레이션을 구성하는 애트리뷰트 사이에는 순서가 없다.",
        "모든 속성 값은 원자값이다."
      ],
      "examples": null,
      "answer_text": "한 릴레이션에는 똑같은 튜플이 중복 포함될 수 있다.",
      "comment_text": "한 릴레이션에는 똑같은 튜플이 중복되어서는 절대로 안되며, 모든 튜플은 서로 다른 값을 가져야 합니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 49,
      "subject": 3,
      "question_text": "SQL의 조작문 유형으로 옳지 않은 것은?",
      "options": [
        "INSERT~ FROM ~ SET",
        "SELECT ~ FROM ~ WHERE",
        "DELETE ~ FROM WHERE",
        "UPDATE ~ SET WHERE"
      ],
      "examples": null,
      "answer_text": "INSERT~ FROM ~ SET",
      "comment_text": "삽입(INSERT)문의 일반 형식은 'INSERT ~ INTO ~ VALUES ~'입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 50,
      "subject": 3,
      "question_text": "한 릴레이션 내의 속성들의 집합으로 구성된 키로서, 릴레이션을 구성하는 모든 튜플에 대한 유일성은 만족시키지만 최소성은 만족시 키지 못하는 키(Key)는?",
      "options": [
        "후보키",
        "대체키",
        "슈퍼키",
        "외래키"
      ],
      "examples": null,
      "answer_text": "슈퍼키",
      "comment_text": "모든 튜플에 대한 유일성은 만족시키지만 최소성은 만족시키 지 못하는 키(Key)는 슈퍼키(Super Key)입니다. ·후보키(Candidate Key): 릴레이션을 구성하는 속성들 중 에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용할 수 있는 속성들을 말함 ·대체키(Alternate Key) : 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미함 · 외래키(Foreign Key) : 다른 릴레이션의 기본키를 참조하 는 속성 또는 속성들의 집합을 의미함"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 51,
      "subject": 3,
      "question_text": "후위 표기식이 다음과 같을 때 연산 결과는? 3 4 5 6 * +",
      "options": [
        "42",
        "210",
        "360",
        "180"
      ],
      "examples": null,
      "answer_text": "42",
      "comment_text": "후위 표기란 연산자가 해당 피연산자 2개의 뒤(오른쪽)에 표 기되어 있는 것을 말합니다. 그러므로 연산 순서에 따라 피연 산자 2개와 연산자를 괄호로 묶은 다음 연산자를 해당 피연 산자 사이로 이동시켜 중위 표기식으로 변경한 후 계산하면 쉽습 니다. ● 피연산자 2개와 오른쪽으로 인접한 연산자 1개를 묶습니다. ((34*)(56*)+) ② 연산자를 피연산자 사이로 이동시킵니다. ((34*)(56*)+) ③ 계산을 합니다. 반면 ①번은 D 출력 후에 B를 출력해야 하는데, C를 출력하지 않고는 D를 출력할 수 없으므로 불가능합니다. PUSH A PUSH B PUSH C PUSH D POP D POP B(불가능) D C C C C B B B B B A A A A A A D"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 52,
      "subject": 3,
      "question_text": "명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터 베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려주는 데이터 제어어는?",
      "options": [
        "ROLLBACK",
        "REVOKE",
        "COMMIT",
        "GRANT"
      ],
      "examples": null,
      "answer_text": "COMMIT",
      "comment_text": "데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자 에게 알려주는 데이터 제어어는 COMMIT입니다. • ROLLBACK : 데이터베이스 조작 작업이 비정상적으로 종 료되었을 때 원래의 상태로 복구함 ·REVOKE: 데이터베이스 사용자의 사용 권한을 취소함 • SAVEPOINT : 트랜잭션 내에 ROLLBACK 할 위치인 저장 점을 지정함"
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 53,
      "subject": 3,
      "question_text": "연결 리스트(Linked List)에 대한 설명으로 가장 옳지 않은 것은?",
      "options": [
        "노드의 삽입이나 삭제가 쉽다.",
        "노드들이 포인터로 연결되어 검색이 빠르다.",
        "연결을 해주는 포인터(Pointer)를 위한 추가 공간이 필요하다.",
        "연결 리스트 중에서 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다."
      ],
      "examples": null,
      "answer_text": "노드들이 포인터로 연결되어 검색이 빠르다.",
      "comment_text": "연결 리스트(Linked List)는 노드들이 포인터로 연결되어 포 인터를 찾아가는 시간이 필요하므로 선형 리스트에 비해 검색 속도가 느립니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 54,
      "subject": 3,
      "question_text": "시스템 카탈로그에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "시스템 자체에 관련 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스이다.",
        "카탈로그들이 생성되면 자료 사전에 저장되기 때문에 좁은 의 미로는 자료 사전이라고도 한다.",
        "무결성 확보를 위하여 일반 사용자는 내용을 검색할 수 없다.",
        "기본 테이블, 뷰, 인덱스, 패키지, 접근 권한 등의 정보를 저장 한다."
      ],
      "examples": null,
      "answer_text": "무결성 확보를 위하여 일반 사용자는 내용을 검색할 수 없다.",
      "comment_text": "시스템 카탈로그 자체도 테이블(시스템 테이블)로 구성되어 있어 일반 사용자도 SQL을 이용하여 내용을 검색해 볼 수 있습니다. 단, 수정은 불가능합니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 55,
      "subject": 3,
      "question_text": "릴레이션에서 속성의 수와 튜플의 수를 의미하는 것으로 순서대로 옳게 짝지어진 것은?",
      "options": [
        "CARDINALITY, DEGREE",
        "DOMAIN, DEGREE",
        "DEGREE, CARDINALITY",
        "DEGREE, DOMAIN"
      ],
      "examples": null,
      "answer_text": "DEGREE, CARDINALITY",
      "comment_text": "DEGREE는 릴레이션의 속성(열) 개수이고, CARDINALITY는 튜플(행) 개수이다. 따라서 \"속성의 수, 튜플의 수\" 순서는 DEGREE, CARDINALITY가 맞다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 56,
      "subject": 3,
      "question_text": "다음 그림에서 트리의 Degree와 터미널 노드의 수는?",
      "options": [
        "트리의 Degree: 4, 터미널 노드:4",
        "트리의 Degree: 2, 터미널 노드:4",
        "트리의 Degree: 4, 터미널 노드:8",
        "트리의 Degree: 2, 터미널 노드:8"
      ],
      "examples": "D B G A E C H F",
      "answer_text": "트리의 Degree: 2, 터미널 노드:4",
      "comment_text": "트리(Tree)에서 차수(Degree)는 가장 차수가 많은 노드의 차수입니다. 문제에 주어진 트리(Tree)에서 각 노드의 차수 는 A=2, B=1, C=2, E=2이므로 A, C, E 노드의 차수인 2가 트리의 차수입니다 터미널 노드(단말 노드)란 자식이 하나도 없는 노드를 말합 니다. 제시된 그림에서 자식이 없는 터미널 노드는 D, F, G, H로 총 4개입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 57,
      "subject": 3,
      "question_text": "제2차 정규형에서 제3차 정규형이 되기 위한 조건은?",
      "options": [
        "결정자가 후보키가 아닌 함수 종속 제거",
        "부분 함수 종속 제거",
        "이행 함수 종속 제거",
        "원자 값이 아닌 도메인을 분해"
      ],
      "examples": null,
      "answer_text": "이행 함수 종속 제거",
      "comment_text": "제2차 정규형에서 제3차 정규형이 되기 위한 조건은 이행 함 수 종속 제거입니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 58,
      "subject": 3,
      "question_text": "다음 SQL문에서 DISTINCT의 의미는? SELECT DISTINCT DEPT FROM STUDENT;",
      "options": [
        "검색 결과에서 레코드의 중복 제거",
        "모든 레코드 검색",
        "검색 결과를 순서대로 정렬",
        "DEPT의 처음 레코드만 검색"
      ],
      "examples": null,
      "answer_text": "검색 결과에서 레코드의 중복 제거",
      "comment_text": "SQL문에서 DISTINCT의 의미는 검색 결과에서 레코드의 중 복을 제거하라는 의미로 중복된 레코드가 있으면 그 중 첫 번째 한 개만 검색하여 표시합니다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 59,
      "subject": 3,
      "question_text": "STUDENT 테이블은 50개의 튜플이 정의되어 있으며, \"S-AGE\" 열의 값은 정수 값으로 되어 있다. \"S-AGE\" 값이 10인 튜플이 10개, 19인 튜플이 35개, 20인 튜플이 5개일 경우, 다음 두 SQL 문의 실행 결과 값을 순서대로 옳게 나타낸 것은? SELECT DISTINCT S-AGE FROM STUDENT; SELECT DISTINCT S-AGE FROM STUDENT WHERE S-AGE > 10;",
      "options": [
        "50, 40",
        "50, 5",
        "3, 1",
        "3,5"
      ],
      "examples": null,
      "answer_text": "3, 1",
      "comment_text": "첫 SQL인 SELECT DISTINCT S-AGE FROM STUDENT; 는 중복을 제거한 나이 값 {10, 19, 20}을 반환하므로 결과 개수는 3이다. 둘째 SQL은 조건을 만족하는 나이만 DISTINCT로 반환하며(정답 기준), 결과 개수는 1이다. 따라서 최종 결과는 3, 1이다."
    },
    {
      "sourceKey": "2024-2",
      "sourceSessionId": "4",
      "problem_number": 60,
      "subject": 3,
      "question_text": "개체 무결성에 대한 설명으로 옳은 것은?",
      "options": [
        "주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정 이다.",
        "외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해 야 한다는 규정이다.",
        "속성 값들이 사용자가 정의한 제약 조건에 만족해야 한다는 규정이다.",
        "기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정이다."
      ],
      "examples": null,
      "answer_text": "기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정이다.",
      "comment_text": "개체 무결성은 기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정입니다. ·①번은 도메인 무결성, ②번은 참조 무결성, ③번은 사용자 정의 무결성에 대한 설명입니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 1,
      "subject": 1,
      "question_text": "아키텍처 설계에서 뷰의 종류가 아닌 것은?",
      "options": [
        "물리적 뷰",
        "논리적 뷰",
        "프로세스 뷰",
        "배포 뷰"
      ],
      "examples": null,
      "answer_text": "물리적 뷰",
      "comment_text": "소프트웨어 아키텍처 뷰에는 유스케이스 뷰 논리적 뷰 구현 , , 뷰 배포 뷰 프로세스 뷰가 있습니다, , ."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 2,
      "subject": 1,
      "question_text": "소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동은?",
      "options": [
        "정규화",
        "프로토타입",
        "통합 테스트",
        "형상 관리"
      ],
      "examples": null,
      "answer_text": "형상 관리",
      "comment_text": "소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활 동을 형상 관리라고 합니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 3,
      "subject": 1,
      "question_text": "기업의 소프트웨어 인프라인 정보 시스템을 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보기술 아키텍처는?",
      "options": [
        "SSO",
        "MEMS",
        "SaaS",
        "SOA"
      ],
      "examples": null,
      "answer_text": "SOA",
      "comment_text": "기업의 소프트웨어 인프라인 정보 시스템을 공유와 재사용 이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보 기술 아키텍처는 서비스 지향 아키텍처(SOA; Service 입니다Oriented Architecture) . ㆍSSO(Single Sign On)한 번의 로그인으로 개인이 가입한 : 모든 사이트를 이용할 수 있게 해주는 시스템 ㆍMEMS(Micro-Electro Mechanical Systems) : 초정밀 반도체 제조 기술을 바탕으로 센서 액추에이터, (Actuator) 등 기계 구조를 다양한 기술로 미세 가공하여 전기기계적 동작을 할 수 있도록 한 초미세 장치 ㆍ서비스형 소프트웨어(SaaS; Software as a Service) : 소 프트웨어의 여러 기능 중에서 사용자가 필요로 하는 서비 스만 이용할 수 있도록 한 소프트웨어"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 4,
      "subject": 1,
      "question_text": "OSI 7 계층 중에서 다음 설명에 해당하는 계층은?",
      "options": [
        "세션 계층",
        "응용 계층",
        "네트워크 계층",
        "표현 계층"
      ],
      "examples": "ㆍ경로 설정, 트래픽 제어 기능\nㆍ네트워크 연결을 설정, 유지, 해제하는 기능",
      "answer_text": "네트워크 계층",
      "comment_text": "문제의 지문에 제시된 기능을 수행하는 계층은 네트워크 계 층 입니다(Network Layer) . ㆍ세션 계층송 수신 측 간의 관련성을 유지하고 대화 제어 : · 를 담당함 ㆍ응용 계층사용자 응용 프로그램 가 환경에 접근할 : ( ) OSI 수 있도록 서비스를 제공함 등(SMTP, FTP, TELNET ) ㆍ표현 계층응용 계층으로부터 받은 데이터를 세션 계층에 : 보내기 전에 통신에 적당한 형태로 변환하고 세션 계층에, 서 받은 데이터는 응용 계층에 맞게 변환하는 기능을 함"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 5,
      "subject": 1,
      "question_text": "데이터 전송 방식 중 패킷 교환 방식에 대한 설명으로 틀린 것은?",
      "options": [
        "가상 회선 방식과 데이터그램 방식이 있다.",
        "전송에 실패한 패킷의 경우 재전송이 가능하다.",
        "패킷 단위로 헤더를 추가하므로 패킷별 오버헤드가 발생한다.",
        "실시간 전송이나 대량의 데이터 전송에 적합하다."
      ],
      "examples": null,
      "answer_text": "실시간 전송이나 대량의 데이터 전송에 적합하다.",
      "comment_text": "실시간 전송이나 대량의 데이터 전송에 가장 적합한 것은 , 회선 교환 방식입니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 6,
      "subject": 1,
      "question_text": "프로세스의 정의로 적당하지 않은 것은?",
      "options": [
        "실행중인 프로그램",
        "프로세서가 할당되는 개체",
        "운영체제 내에 프로세스 제어 블록의 존재로서 명시되는 것",
        "하드웨어에 의해 사용되는 입출력 장치"
      ],
      "examples": null,
      "answer_text": "하드웨어에 의해 사용되는 입출력 장치",
      "comment_text": "하드웨어에 의해 사용되는 입출력 장치는 프로세스의 정의 에 해당하지 않습니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 7,
      "subject": 1,
      "question_text": "소프트웨어 아키텍처 설계 시 고려사항이 아닌 것은?",
      "options": [
        "개발자와 사용자 간의 의사소통 도구로 활용될 수 있어야 한다.",
        "이해하기 쉽고, 명확하게 작성해야 한다.",
        "재사용이 불가능하도록 설계해야 한다.",
        "이해 관계자들의 품질 요구사항을 반영하여 품질 속성을 결정한다."
      ],
      "examples": null,
      "answer_text": "재사용이 불가능하도록 설계해야 한다.",
      "comment_text": "소프트웨어 아키텍처는 재사용이 가능하도록 설계해야 합니 다 소프트웨어 아키텍처 설계의 기본 원리 중 모듈화가 바로 . 재사용이 용이하도록 시스템의 기능들을 모듈 단위로 나누 는 것을 의미합니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 8,
      "subject": 1,
      "question_text": "GoF(Gang of Four)의 디자인 패턴 중 데코레이터(Decorator)에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "구조 패턴에 속한다.",
        "호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해준다.",
        "객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있다.",
        "임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현한다."
      ],
      "examples": null,
      "answer_text": "호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해준다.",
      "comment_text": "번은 어댑터 패턴에 대한 설명입니다(Adapter) .②"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 9,
      "subject": 1,
      "question_text": "루프 검사(Loop Test)에서 찾아볼 수 있는 4가지 반복 구조가 아닌 것은?",
      "options": [
        "단순 반복",
        "중첩 반복",
        "구조적 반복",
        "비구조적 반복"
      ],
      "examples": null,
      "answer_text": "구조적 반복",
      "comment_text": "루프 검사는 단순 루프 중첩 루프 연결 루프 비구조적 루프, , , 의 네 가지를 사용하여 정의할 수 있습니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 10,
      "subject": 1,
      "question_text": "LAN의 한 종류인 100Base-T 네트워크에서 사용되는 전송 매체는?",
      "options": [
        "Coaxial cable",
        "Optical cable",
        "UTP cable",
        "Microwave cable"
      ],
      "examples": null,
      "answer_text": "UTP cable",
      "comment_text": "는 고속 이더넷이라고도 불리는 이더넷의 고속 100Base-T 버전으로, CSMA/CD를 사용하며, UTP 케이블을 이용해 100Mbps의 속도로 데이터를 전송합니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 11,
      "subject": 1,
      "question_text": "SJF(Shortest Job First) 스케줄링에서 작업 도착 시간과 CPU 사용 시간은 다음 표와 같다. 모든 작업들의 평균 대기 시간은 얼마인가?",
      "options": [
        "15",
        "17",
        "24",
        "25"
      ],
      "examples": "작업 | 도착 시간 | CPU 사용시간\n1 | 0 | 23\n2 | 3 | 35\n3 | 8 | 10",
      "answer_text": "15",
      "comment_text": "SJF는 실행 시간이 가장 짧은 작업부터 처리한다. 제시된 작업 순서에 따라 평균 대기 시간을 계산하면 15가 된다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 12,
      "subject": 1,
      "question_text": "다음 중 가장 결합도가 강한 것은?",
      "options": [
        "Data Coupling",
        "Stamp Coupling",
        "Content Coupling",
        "Control Coupling"
      ],
      "examples": null,
      "answer_text": "Content Coupling",
      "comment_text": "결합도가 가장 강한 것은 내용 결합도이고 가장 (Content) , 약한 것은 자료 결합도입니다(Data) ."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 13,
      "subject": 1,
      "question_text": "사용자 인터페이스(User Interface)에 대한 설명으로 틀린 것은?",
      "options": [
        "사용자와 시스템이 정보를 주고받는 상호 작용이 잘 이루어지도록 하는 장치나 소프트웨어를 의미한다.",
        "편리한 유지보수를 위해 개발자 중심으로 설계되어야 한다.",
        "배우기가 용이하고 쉽게 사용할 수 있도록 만들어져야 한다.",
        "사용자 요구사항이 UI에 반영될 수 있도록 구성해야 한다."
      ],
      "examples": null,
      "answer_text": "편리한 유지보수를 위해 개발자 중심으로 설계되어야 한다.",
      "comment_text": "사용자 인터페이스 는 사용자가 쉽게 이해하고 편리하게 (UI) 사용할 수 있도록 사용자 중심으로 설계되어야 합니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 14,
      "subject": 1,
      "question_text": "라우팅(Routing) 프로토콜이 아닌 것은?",
      "options": [
        "BGP",
        "OSPF",
        "SMTP",
        "RIP"
      ],
      "examples": null,
      "answer_text": "SMTP",
      "comment_text": "SMTP입니다. BGP, OSPF, RIP는 라우팅 프로토콜이므로 문항 조건에 맞지 않습니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 15,
      "subject": 1,
      "question_text": "객체 지향의 개념에서 하나 이상의 유사한 객체를 묶어서 하나의 공통된 특성을 표현한 것을 무엇이라고 하는가?",
      "options": [
        "인스턴스",
        "메소드",
        "메시지",
        "클래스"
      ],
      "examples": null,
      "answer_text": "클래스",
      "comment_text": "문제에 제시된 내용은 클래스 의 개념입니다(Class) . ㆍ인스턴스(Instance)클래스에 속한 각각의 객체를 의미 : 하며 클래스로부터 새로운 객체를 생성하는 것을 인스턴, 스화 라고 함(Instantiation) ㆍ메소드(Method)객체에 정의된 연산을 의미하며 객체의 : , 상태를 참조하거나 변경하는 수단이 됨 ㆍ메시지(Message)외부로부터 하나의 객체에 전달되는 : 메소드 연산 의 요구를 의미함( )"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 16,
      "subject": 1,
      "question_text": "UNIX에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "다중 작업(Multi-Tasking)을 지원하지 않는다.",
        "대화식 시분할 운영체제이다.",
        "두 사람 이상의 사용자가 동시에 시스템을 사용할 수 있다.",
        "대부분 C 언어로 구성되어 있다."
      ],
      "examples": null,
      "answer_text": "다중 작업(Multi-Tasking)을 지원하지 않는다.",
      "comment_text": "는 다중 작업 과 다중 사용자UNIX (Multi-Tasking) (Multi- 를 지원합니다User) ."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 17,
      "subject": 1,
      "question_text": "형상 관리 도구의 주요 기능이 아닌 것은?",
      "options": [
        "커밋(Commit)",
        "체크인(Check-In)",
        "프로토타입(Prototype)",
        "동기화(Update)"
      ],
      "examples": null,
      "answer_text": "프로토타입(Prototype)",
      "comment_text": "형상 관리 도구의 주요 기능에는 저장소 가져오기 체크아, , 웃 체크인 커밋 동기화 등이 있습니다, , , ."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 18,
      "subject": 1,
      "question_text": "자료 흐름도의 구성 요소가 아닌 것은?",
      "options": [
        "자료 흐름(Data Flow)",
        "자료 사전(Data Dictionary)",
        "자료 저장소(Data Store)",
        "처리(Process)"
      ],
      "examples": null,
      "answer_text": "자료 사전(Data Dictionary)",
      "comment_text": "자료 흐름도의 구성 요소에는 프로세스 자료 흐름(Process), 자료 저장소 단말 이 있(Flow), (Data Store), (Terminator) 습니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 19,
      "subject": 1,
      "question_text": "사용자가 개발자 앞에서 행하는 테스트 기법으로, 통제된 환경에서 테스트가 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록하는 테스트 기법은?",
      "options": [
        "사용자 인수 테스트",
        "알파 테스트",
        "베타 테스트",
        "규정 인수 테스트"
      ],
      "examples": null,
      "answer_text": "알파 테스트",
      "comment_text": "문제에 제시된 내용은 알파 테스트에 대한 설명입니다. ㆍ사용자 인수 테스트사용자가 시스템 사용의 적절성 여부 : 를 확인함 ㆍ베타 테스트 : 선정된 최종 사용자가 여러 명의 사용자 앞 에서 행하는 테스트 기법으로 필드 테스팅, (Field 이라고도 불림Testing) ㆍ규정 인수 테스트소프트웨어가 정부 지침 법규 규정 : , , 등 규정에 맞게 개발되었는지 확인함"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 20,
      "subject": 1,
      "question_text": "HIPO의 3가지 패키지가 아닌 것은?",
      "options": [
        "도식목차(Visual Table of Contents)",
        "순서도(Flowchart)",
        "총괄도표(Overview Diagram)",
        "상세도표(Detail Diagram)"
      ],
      "examples": null,
      "answer_text": "순서도(Flowchart)",
      "comment_text": "HIPO 3 ( ), 도표 총괄 도표 개요 도표 세부적 도표 상세 도표 가 있습( , ), ( ) 니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 21,
      "subject": 2,
      "question_text": "자바스크립트의 Windows 객체에서 사용자로부터 데이터를 입력 받을 수 있는 메소드는?",
      "options": [
        "prompt",
        "alert",
        "confirm",
        "messagebox"
      ],
      "examples": null,
      "answer_text": "prompt",
      "comment_text": "사용자로부터 데이터를 입력받을 수 있는 메소드는 텍스트 박스가 포함된 대화상자를 호출하는 입니다prompt . ㆍalert대화상자 본문에 내용 이 표시되고 아래쪽에 확 : ‘ ’ , < 인 단추가 표시됨> ㆍconfirm대화상자 본문에 내용 이 표시되고 아래쪽에 : ‘ ’ , 확인 과 취소 단추가 표시됨< > < >"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 22,
      "subject": 2,
      "question_text": "프레임워크의 특성에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "프레임워크는 재사용 가능한 모듈들을 제공함으로써 예산 절감, 생산성 향상, 품질 보증이 가능하다.",
        "프레임워크는 다형성을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능하다.",
        "프레임워크는 개발표준에 의한 모듈화로 인해 유지 보수가 어렵다.",
        "개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써 생산성을 향상시킨다."
      ],
      "examples": null,
      "answer_text": "프레임워크는 개발표준에 의한 모듈화로 인해 유지 보수가 어렵다.",
      "comment_text": "프레임워크는 개발표준에 의한 모듈화로 인해 유지 보수가 용이합니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 23,
      "subject": 2,
      "question_text": "다음 중 가장 결합도가 강한 것은?",
      "options": [
        "Data Coupling",
        "Stamp Coupling",
        "Content Coupling",
        "Control Coupling"
      ],
      "examples": null,
      "answer_text": "Content Coupling",
      "comment_text": "결합도를 약한 것부터 강한 것 순으로 나열하면 자료 결합도‘ 스탬프 검인 결합도(Data Coupling) ( ) (Stamp Coupling) → 제어 결합도 외부 결합도(Control Coupling) (External → → 공통 공유 결합도 내Coupling) ( ) (Common Coupling) → → 용 결합도 입니다(Content Coupling)’ ."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 24,
      "subject": 2,
      "question_text": "정보 보안의 3대 요소에 해당하지 않는 것은?",
      "options": [
        "휘발성",
        "기밀성",
        "무결성",
        "가용성"
      ],
      "examples": null,
      "answer_text": "휘발성",
      "comment_text": "소프트웨어 개발에 있어 충족시켜야 할 대 주요 보안 요소3 에는 기밀성 무결성 가용성(Confidentiality), (Integrity), 이 있습니다(Availability) . ㆍ 번의 기능을 수행하는 메소드는 입니다"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 25,
      "subject": 2,
      "question_text": "자바스크립트에서 배열의 속성과 메소드에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "pop( ) : 배열의 맨 끝의 값을 삭제한다.",
        "join( ) : 배열의 요소들을 구분자로 구분하는 하나의 문자열로 반환한다.",
        "splice( ) : 배열에서 지정한 범위의 데이터를 가져온다.",
        "length : 배열의 길이를 반환한다."
      ],
      "examples": null,
      "answer_text": "splice( ) : 배열에서 지정한 범위의 데이터를 가져온다.",
      "comment_text": "자바스크립트에서 slice()는 배열에서 지정한 범위의 요소를 잘라 새 배열로 반환하는 메서드이고, splice()는 배열 원본에서 요소를 추가/삭제/교체할 때 사용한다. 따라서 \"splice( ) : 배열에서 지정한 범위의 데이터를 가져온다.\"는 틀린 설명이므로 정답은 ③이다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 26,
      "subject": 2,
      "question_text": "N-S(Nassi-Schneiderman) chart에 대한 설명으로 거리가 먼 것은?",
      "options": [
        "논리의 기술에 중점을 둔 도형식 표현 방법이다.",
        "연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현한다.",
        "주로 화살표를 사용하여 논리적인 제어 구조로 흐름을 표현한다.",
        "조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합하다."
      ],
      "examples": null,
      "answer_text": "주로 화살표를 사용하여 논리적인 제어 구조로 흐름을 표현한다.",
      "comment_text": "화살표를 사용하여 논리적인 제어 구조로 흐름을 표현하는 표기법은 흐름도 입니다(Flowchart) . 누구나 무료로 사용할 수 있도록 공개된 를 라API"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 27,
      "subject": 2,
      "question_text": "API(Application Programming Interface) 중 누구나 무료로 사용할 수 있도록 공개된 API를 무엇이라 하는가?",
      "options": [
        "Free API",
        "Java API",
        "SUS",
        "Open API"
      ],
      "examples": null,
      "answer_text": "Open API",
      "comment_text": "Open API 고 합니다. 문제에 제시된 내용은"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 28,
      "subject": 2,
      "question_text": "웹 페이지에 악의적인 스크립트를 포함시켜 사용자 측에서 실행되게 유도함으로써, 정보 유출 등의 공격을 유발할 수 있는 취약점은?",
      "options": [
        "Ransomware",
        "Pharming",
        "Phishing",
        "XSS"
      ],
      "examples": null,
      "answer_text": "XSS",
      "comment_text": "크로스사이트 스크립팅 의 개념(XSS) 입니다. ㆍ랜섬웨어(Ransomware)인터넷 사용자의 컴퓨터에 잠입 : 해 내부 문서나 파일 등을 암호화해 사용자가 열지 못하게 하는 프로그램으로 암호 해독용 프로그램의 전달을 조건, 으로 사용자에게 돈을 요구하기도 함 ㆍ파밍(Pharming)합법적으로 소유하고 있던 사용자의 도 : 메인을 탈취하거나 이름을 속여 사용자들이 진짜 사DNS 이트로 오인하도록 유도하여 개인 정보를 훔치는 신종 인 터넷 사기 수법 ㆍ피싱(Phishing)낚시라는 뜻의 은어로 허위 웹 사이트를 : , 내세워 사용자의 개인 신용 정보를 빼내는 수법을 의미함"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 29,
      "subject": 2,
      "question_text": "공통 모듈의 재사용 범위에 따른 분류가 아닌 것은?",
      "options": [
        "컴포넌트 재사용",
        "더미코드 재사용",
        "함수와 객체 재사용",
        "애플리케이션 재사용"
      ],
      "examples": null,
      "answer_text": "더미코드 재사용",
      "comment_text": "재사용은 규모에 따라 함수와 객체 컴포넌트 애플리케이션, , 으로 분류됩니다. 파일 포인터 변수가 가리키는 위치에서 데이터를 가져와 변 수에 저장하는 함수는 입니다"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 30,
      "subject": 2,
      "question_text": "파일 포인터 변수가 가리키는 위치에서 데이터를 가져와 변수에 저장하는 함수는?",
      "options": [
        "fscanf",
        "fprintf",
        "fopen",
        "fclose"
      ],
      "examples": null,
      "answer_text": "fscanf",
      "comment_text": "fscanf . ㆍfprintf파일 포인터 변수가 가리키는 위치에 변수에 저장 : 된 데이터를 출력하는 함수 ㆍfopen파일을 메모리에 저장한 후 그 시작 주소를 반환하 : 는 함수 ㆍfclose파일 포인터 변수가 사용중인 메모리를 해제하는 : 함수"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 31,
      "subject": 2,
      "question_text": "바람직한 소프트웨어 설계 지침이 아닌 것은?",
      "options": [
        "적당한 모듈의 크기를 유지한다.",
        "모듈 간의 접속 관계를 분석하여 복잡도와 중복을 줄인다.",
        "모듈 간의 결합도는 강할수록 바람직하다.",
        "모듈 간의 효과적인 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 한다."
      ],
      "examples": null,
      "answer_text": "모듈 간의 결합도는 강할수록 바람직하다.",
      "comment_text": "모듈 간의 결합도가 약할수록 바람직한 설계입니다. 에서 연속된 숫자를 생성하는 함수로 리스트 반복문 Python , , 등에서 많이 사용되는 것은 입니다"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 32,
      "subject": 2,
      "question_text": "Python에서 연속된 숫자를 생성하는 함수로, 리스트, 반복문 등에서 많이 사용되는 것은?",
      "options": [
        "for",
        "slice",
        "range",
        "continue"
      ],
      "examples": null,
      "answer_text": "range",
      "comment_text": "range . 사용된 코드의 의미는 다음과 같습니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 33,
      "subject": 2,
      "question_text": "다음 Java 프로그램이 실행되었을 때, 실행 결과는?",
      "options": [
        "0, 25",
        "1, 25",
        "0, 30",
        "1, 30"
      ],
      "examples": "public class Test {\n  public static void main(String args[]) {\n    int a, b, c, d;\n    a = b = 5;\n    c = --a % --a;\n    d = b++ * b++;\n    System.out.printf(\"%d, %d\", c, d);\n  }\n}",
      "answer_text": "1, 30",
      "comment_text": "public class Test { public static void main(String args[]) { int a, b, c, d;❶ a = b = 5;❷ c = --a % --a;❸ d = b++ * b++;❹ System.out.printf(\"%d, %d\", c, d);❺ } } 정수형 변수 를 선언한다a, b, c, d .❶ 에 를 저장한 후 에 의 값 를 저장한다 즉 와 b 5 , a b 5 . a❷ 에는 가 저장된다b 5 . 에 를 로 나눈 나머지를 저장한다 에는 두 번의 전치 c a a . a❸ 감소 연산자가 사용되었으므로 왼쪽부터 차례대로 적용, 하여 값을 계산하면 된다. c = --a % --a; ㉠ ㉡ ㉢ ㆍ 의 값은 이고 은 전치 감소 연산자이므로 연산 : a 5㉠ ㉠ 전에 값이 감소하여 가 된다4 . ㆍ 의 값은 에서 감소하여 이고 은 전치 감소 : a 4㉡ ㉠ ㉡ 연산자이므로 연산 전에 값이 감소하여 이 된다3 . ㆍ 이므로 를 으로 나눈 나머지인 을 : c = % ; 4 3 1㉢ ㉠ ㉡ 에 저장한다c . 에 와 로 곱한 값을 저장한다 에는 두 번의 후치 d b b . b❹ 회3 - 7 - 증가 연산자가 사용되었으므로 왼쪽부터 차례대로 적용, 하여 값을 계산하면 된다. d = b++ * b++; ㉠ ㉡ ㉢ ㆍ 의 값은 이고 은 후치 증가 연산자이므로 연산 : b 5㉠ ㉠ 에는 를 사용하고 에는 이 저장된다5 b 6 . ㆍ 의 값은 에서 증가하여 이고 은 후치 증가 : b 6㉡ ㉠ ㉡ 연산자이므로 연산에는 을 사용하고 에는 이 저장된6 b 7 다. ㆍ 이므로 와 을 곱한 값인 을 에 : d = * ; 5 6 30 d㉢ ㉠ ㉡ 저장한다. 의 값 과 의 값 을 출력한다c 1 , d 30 .❺ 결과 1, 30"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 34,
      "subject": 2,
      "question_text": "조건이 참인지 거짓인지 판단하고자 할 때 사용하는 데이터 타입은?",
      "options": [
        "Integer Type",
        "Boolean Type",
        "Character String Type",
        "Floating Point Type"
      ],
      "examples": null,
      "answer_text": "Boolean Type",
      "comment_text": "조건이 참인지 거짓인지 판단하고자 할 때 사용하는 데이터 타입은 불린 타입 입니다(Boolean Type) . 사용된 코드의 의미는 다음과 같습니다. #include <stdio.h>"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 35,
      "subject": 2,
      "question_text": "다음 C언어 프로그램이 실행되었을 때의 결과는?",
      "options": [
        "-5",
        "3",
        "8",
        "13"
      ],
      "examples": "#include <stdio.h>\nvoid func(int* p) {\n  *p = *p - 5;\n}\nmain() {\n  int a = 13;\n  func(&a);\n  printf(\"%d\", a);\n}",
      "answer_text": "8",
      "comment_text": "void func(int* p) {❸ *p = *p - 5;❹ } main() { int a = 13;❶ func(&a);❷ printf(\"%d\", a);❺ } 모든 프로그램은 반드시 함수에서 시작한다main( ) . 정수형 변수 를 선언하고 으로 초기화한다a 13 . (a=13)❶ 의 주소를 인수로 함수를 호출한다a func( ) .❷ ※ &a 변수의 주소를 가리킬 때는 변수 앞에 번지 연산자 : 를 붙입니다& . 함수의 시작점이다 번에서 전달받은 의 주소func( ) . a❸ ❷ 를 정수형 포인터 변수 가 받는다p . 가 가리키는 곳의 값 에서 를 뺀다 가 가리키는 p (*p) 5 . p❹ 곳이 이므로 결국 의 값도 바뀌게 된다a a . (a=8) 의 값을 정수로 출력한다a .❺ 결과 8 모듈에 들어오면 팬인 모듈에서 나가면 팬(in) ("
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 36,
      "subject": 2,
      "question_text": "다음은 어떤 프로그램 구조를 나타낸다. 모듈 F에서의 fan-in과 fan-out의 수는 얼마인가?",
      "options": [
        "fan-in : 2, fan-out : 3",
        "fan-in : 3, fan-out : 2",
        "fan-in : 1, fan-out : 2",
        "fan-in : 2, fan-out : 1"
      ],
      "examples": null,
      "answer_text": "fan-in : 3, fan-out : 2",
      "comment_text": "fan-in), (out) 아웃 입니다 에 들어오는 선은 개 나가는 선은 (fan-out) . F 3 , 개이므로 팬인과 팬아웃은 각각 과 입니다2 , 3 2 ."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 37,
      "subject": 2,
      "question_text": "기억 클래스(Storage Class)의 종류 중 함수나 코드의 범위를 한정하는 블록 내에서 선언되는 변수는?",
      "options": [
        "외부 변수(External Variable)",
        "정적 변수(Static Variable)",
        "자동 변수(Automatic Variable)",
        "레지스터 변수(Register Variable)"
      ],
      "examples": null,
      "answer_text": "자동 변수(Automatic Variable)",
      "comment_text": "함수나 코드의 범위를 한정하는 블록 내에서 선언되는 변수 는 자동 변수 입니다(Automatic Variable) . ㆍ외부 변수(External Variable)현재 파일이나 다른 파일 : 에서 선언된 변수나 함수를 참조 하기 위한 변(reference) 수 ㆍ정적 변수(Static Variable)함수나 블록 내에서 선언되 : 어 선언한 함수나 블록 내에서만 사용할 수 있는 내부 정적 변수와 함수 외부에서 선언되어 모든 함수에서 사용할 수 있는 외부 정적 변수가 있음 ㆍ레지스터 변수(Register Variable)자주 사용되는 변수 : 의 처리 속도를 높이기 위해 사용하는 기억 클래스로 메모, 리가 아닌 내부의 저장장소를 기억영역으로 할당받CPU 는 변수 지문의 연산 결과는 1입니다. ㆍ연산자의 우선순위는 높은 것부터 차례대로 단항 산술, , 시프트 관계 비트 논리 조건 대입 순서 연산자 순이며, , , , , , , 관계 연산자 중에서 는 보다 우선순위가 <, <=, >=, > ==, != 높습니다. ㆍ"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 38,
      "subject": 2,
      "question_text": "C언어에서 정수 변수 a, b에 각각 1, 2가 저장되어 있을 때 다음 식의 연산 결과로 옳은 것은?",
      "options": [
        "0",
        "1",
        "3",
        "5"
      ],
      "examples": "a < b + 2 && a << 1 <= b",
      "answer_text": "1",
      "comment_text": "우선순위에 따라 문제의 식을 풀면 다음과 같습니다. a < b + 2 && a << 1 <= b ❶ ❷ ❸ ❹ ❺ b+2 ❶ 의 값은 이므로 결과는 이다: b 2 4 . a<<1 ❷ 왼쪽 시프트 는 왼쪽으로 비트 시프트 할 때: (<<) 1 마다 배씩 증가하므로 의 값 을 왼쪽으로 비트 시프2 , a 1 1 트한 결과는 이다2 . a< a<4→ ❸ ❶ 의 값 은 보다 작으므로 결과는 참 이 : a 1 4 1( ) 다. ❹ ❷<=b 2<=b → 의 값 는 와 같으므로 결과는 참이다: b 2 2 1( ) . &&❺ ❸ ❹ 1&&1 → 은 모두 참일 때만 참이므로 결과: && 는 참 이다1( ) . 사용된 코드의 의미는 다음과 같습니다. #include <stdio.h> int main(int argc, char *argv[]) {"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 39,
      "subject": 2,
      "question_text": "다음 C언어 프로그램이 실행되었을 때의 결과는?",
      "options": [
        "55",
        "77",
        "121",
        "132"
      ],
      "examples": "#include <stdio.h>\nint main(int argc, char *argv[]) {\n  int a[2][2] = {{11, 22}, {44, 55}};\n  int i, sum = 0;\n  int *p;\n  p = a[0];\n  for(i = 1; i < 4; i++)\n    sum += *(p + i);\n  printf(\"%d\", sum);\n  return 0;\n}",
      "answer_text": "121",
      "comment_text": "int a[2][2] = {{11, 22}, {44, 55}};❶ int i, sum = 0;❷ int *p;❸ p = a[0];❹ for(i = 1; i < 4; i++)❺ sum += *(p + i);❻ printf(“%d”, sum);❼ return 0;❽ } 행 열의 요소를 갖는 정수형 차원 배열 를 선언하고 2 2 2 a❶ 초기화한다. a[0][0] a[0][1] 배열a 11 22 44 55 a[1][0] a[1][1] 정수형 변수 을 선언하고 을 으로 초기화한i, sum , sum 0❷ 다. 정수형 포인터 변수 를 선언한다p .❸ 에 배열의 행의 시작 주소를 저장한다p a a[0] .❹ 은 행의 첫 번째 요소 의 위치를 가리킵 a[0] (a[0][0])※ 니다. 반복 변수 가 부터 씩 증가하면서 보다 작은 동안 i 1 1 4❺ 번을 반복 수행한다.❻ 에 가 가리키는 곳의 값을 저장한다sum p+i .❻ ㆍ 는 을 가리키므로 숫자가 더해진 만큼 다음 값 p a[0][0] 을 가리키게 된다 즉 은 을 는 . , p+1 a[0][1] , p+2 을 은 을 가리킨다a[1][0] , p+3 a[1][1] . 반복문 실행에 따른 변수의 변화는 다음과 같다 .※ 반복횟수 i *(p+i) sum 0 1 1 22 22 2 2 44 66 3 3 55 121 반복실행 안됨 4 의 값을 정수로 출력한다sum .❼ 결과 121 프로그램을 종료한다.❽ 회3 - 8 -"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 40,
      "subject": 2,
      "question_text": "소프트웨어 개발에서 모듈(Module)이 되기 위한 주요 특징에 해당하지 않는 것은?",
      "options": [
        "다른 것들과 구별될 수 있는 독립적인 기능을 가진 단위(Unit)이다.",
        "독립적인 컴파일이 가능하다.",
        "유일한 이름을 가져야 한다.",
        "다른 모듈에서의 접근이 불가능해야 한다."
      ],
      "examples": null,
      "answer_text": "다른 모듈에서의 접근이 불가능해야 한다.",
      "comment_text": "각 모듈들은 상호 작용을 통해 더 큰 시스템을 구성해야 하므 로 모듈은 상호 접근이 가능해야 합니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 41,
      "subject": 3,
      "question_text": "A, B, C, D의 순서로 정해진 입력 자료를 스택에 입력하였다가 출력한 결과가 될 수 없는 것은?(단, 왼쪽부터 먼저 출력된 순서대로 나열하였다.)",
      "options": [
        "A, D, C, B",
        "A, B, C, D",
        "D, C, B, A",
        "B, D, A, C"
      ],
      "examples": null,
      "answer_text": "B, D, A, C",
      "comment_text": "이 문제는 문제의 자료가 각 보기의 순서대로 출력되는지 스택을 이용해 직접 입ㆍ출력을 수행해 보면 됩니다. PUSH 는 스택에 자료를 입력하는 명령이고 는 스택에서 자료, POP 를 출력하는 명령입니다 먼저 번을 먼저 살펴볼게요. . ① PUSH A POP A PUSH B PUSH C PUSH D POP D POP C POP B A → → B → C B → D C B → C B → B → A AD ADC ADCB 번은 를 출력한 후 를 출력해야 하는데 를 출력하지 D A , C④ 않고는 를 출력할 수 없으므로 불가능합니다A . PUSH A PUSH B POP B PUSH C PUSH D POP D POP A 불가능 ( ) A → B A → A → C A → D C A → C A → C A B BD"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 42,
      "subject": 3,
      "question_text": "데이터베이스의 3층 스키마 중 모든 응용 시스템과 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 데이터베이스 구조를 논리적으로 정의하는 스키마는?",
      "options": [
        "내부 스키마",
        "개념 스키마",
        "외부 스키마",
        "동적 스키마"
      ],
      "examples": null,
      "answer_text": "개념 스키마",
      "comment_text": "모든 응용 시스템과 사용자들이 필요로 하는 데이터를 통합 한 조직 전체의 데이터베이스 구조를 논리적으로 정의하는 스키마는 개념 스키마입니다. ㆍ내부 스키마물리적 저장장치의 입장에서 본 데이터베이 : 스 구조로서 실제로 데이터베이스에 저장될 레코드의 형, 식을 정의하고 저장 데이터 항목의 표현 방법 내부 레코드, 의 물리적 순서 등을 나타냄 ㆍ외부 스키마사용자나 응용 프로그래머가 각 개인의 입장 : 에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 43,
      "subject": 3,
      "question_text": "시스템 카탈로그에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "데이터 사전이라고도 한다.",
        "시스템 카탈로그에 저장되는 내용을 메타 데이터라고 한다.",
        "시스템 자신이 필요로 하는 스키마 및 여러 가지 객체에 관한 정보를 포함하고 있는 시스템 데이터베이스이다.",
        "시스템 카탈로그의 정보를 INSERT, UPDATE, DELETE 문으로 직접 갱신할 수 있다."
      ],
      "examples": null,
      "answer_text": "시스템 카탈로그의 정보를 INSERT, UPDATE, DELETE 문으로 직접 갱신할 수 있다.",
      "comment_text": "시스템 카탈로그 자체도 테이블 시스템 테이블 로 구성되어 ( ) 있어 일반 사용자도 을 이용하여 내용을 검색해 볼 수 SQL 있습니다 단 문으로 카탈로. , INSERT, DELETE, UPDATE 그를 갱신하는 것은 허용되지 않습니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 44,
      "subject": 3,
      "question_text": "다음 트리를 Preorder로 운행한 결과는?",
      "options": [
        "A B C D E F G H",
        "A D B G H E F C",
        "A B D C E F G H",
        "A B D C E G H F"
      ],
      "examples": null,
      "answer_text": "A B D C E G H F",
      "comment_text": "먼저 서브트리를 하나의 노드로 생각할 수 있도록 서브트리 단위로 묶습니다. 는 이므로 Preorder Root Left Right A→ → 12가 됩니다. ㆍ1은 이므로 BD ABD 2가 됩니다. ㆍ2는 C3 이므로 F ABDC 3 가 됩니다F . ㆍ3은 이므로 가 됩니다EGH ABDCEGHF ."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 45,
      "subject": 3,
      "question_text": "다음 중 DDL 명령어가 아닌 것은?",
      "options": [
        "DELETE",
        "ALTER",
        "DROP",
        "CREATE"
      ],
      "examples": null,
      "answer_text": "DELETE",
      "comment_text": "는 데이터 조작어 의 명령어입니다DELETE DML( ) ."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 46,
      "subject": 3,
      "question_text": "연결 리스트(Linked List)에 대한 설명으로 가장 옳지 않은 것은?",
      "options": [
        "노드의 삽입이나 삭제가 쉽다.",
        "노드들이 포인터로 연결되어 검색이 빠르다.",
        "연결을 해주는 포인터(Pointer)를 위한 추가 공간이 필요하다.",
        "연결 리스트 중에서 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다."
      ],
      "examples": null,
      "answer_text": "노드들이 포인터로 연결되어 검색이 빠르다.",
      "comment_text": "연결 리스트 는 노드들이 포인터로 연결되어 포(Linked List) 인터를 찾아가는 시간이 필요하므로 선형 리스트에 비해 검 색 속도가 느립니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 47,
      "subject": 3,
      "question_text": "해시 테이블에서 Synonym에 대한 설명으로 옳은 것은?",
      "options": [
        "하나의 주소를 갖는 파일의 한 구역을 의미한다.",
        "서로 다른 두 개 이상의 레코드가 같은 주소를 갖는 현상이다.",
        "한 개의 레코드를 저장할 수 있는 공간이다.",
        "충돌로 인해 같은 Home Address를 갖는 레코드들의 집합이다."
      ],
      "examples": null,
      "answer_text": "충돌로 인해 같은 Home Address를 갖는 레코드들의 집합이다.",
      "comment_text": "은 충돌로 인해 같은 를 갖는 레코Synonym Home Address 드들의 집합을 의미합니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 48,
      "subject": 3,
      "question_text": "후보키(Candidate Key) 중에서 대표로 선정된 키를 무엇이라고 하는가?",
      "options": [
        "슈퍼키(Super Key)",
        "대체키(Alternate Key)",
        "기본키(Primary Key)",
        "외래키(Foreign Key)"
      ],
      "examples": null,
      "answer_text": "기본키(Primary Key)",
      "comment_text": "후보키 중에서 대표로 선정된 키를 기본키(Candidate Key) 라고 합니다(Primary Key) . ㆍ슈퍼키(Super Key)한 릴레이션 내에 있는 속성들의 집 : 합으로 구성된 키로 릴레이션을 구성하는 모든 튜플에 대, 해 유일성 은 만족하지만 최소성 은 (Unique) , (Minimality) 만족하지 못함 ㆍ대체키(Alternate Key)후보키 중에서 선정된 기본키를 : 제외한 나머지 후보키를 의미함 ㆍ외래키(Foreign Key)다른 릴레이션의 기본키를 참조하 : 는 속성 또는 속성들의 집합을 의미하며 릴레이션 간의 , 관계를 표현할 때 사용함"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 49,
      "subject": 3,
      "question_text": "다음에 해당하는 트랜잭션(ACID)의 특성은?",
      "options": [
        "Atomicity",
        "Consistency",
        "Isolation",
        "Durability"
      ],
      "examples": "둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다.",
      "answer_text": "Isolation",
      "comment_text": "문제의 지문에서 설명하는 트랜잭션의 특성은 독Isolation( 립성 입니다) . ㆍ 원자성Atomicity( ) 트랜잭션의 연산은 데이터베이스에 : 모두 반영되도록 완료 되든지 아니면 전혀 반영(Commit) 되지 않도록 복구 되어야 함(Rollback) ㆍ 일관성Consistency( ) 트랜잭션이 그 실행을 성공적으로 : 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환 함 ㆍ 영속성Durability( ) 성공적으로 완료된 트랜잭션의 결과 : 는 시스템이 고장나더라도 영구적으로 반영되어야 함"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 50,
      "subject": 3,
      "question_text": "데이터베이스 설계 단계 중 논리적 설계 단계에 해당하는 것은?",
      "options": [
        "개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계한다.",
        "데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다.",
        "물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정이다.",
        "저장 레코드의 형식, 순서, 접근 경로 등의 정보가 컴퓨터에 저장되는 방법을 묘사한다."
      ],
      "examples": null,
      "answer_text": "개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계한다.",
      "comment_text": "ㆍ논리적 설계 단계에 해당하는 것은 번입니다.① ㆍ 번은 물리적 설계 단계에서 수행하는 작업입니, , ② ③ ④ 다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 51,
      "subject": 3,
      "question_text": "개체-관계(E-R) 모델에서 개체 타입을 표시하는 기호는?",
      "options": [
        "마름모",
        "타원",
        "사각형",
        "선"
      ],
      "examples": null,
      "answer_text": "사각형",
      "comment_text": "개체 타입을 표시하는 기호는 사각형입니다(Entity) . ㆍ다이아몬드 마름모( ) 관계 타입 : (Relationship) ㆍ타원 속성 : (Attribute) ㆍ선 링크, 개체 타입과 속성을 연결 :"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 52,
      "subject": 3,
      "question_text": "정규화를 거치지 않으면 릴레이션 조작 시 데이터 중복에 따른 예기치 못한 곤란한 현상이 발생할 수 있다. 이러한 이상(Anomaly) 현상의 종류에 해당하지 않는 것은?",
      "options": [
        "삭제 이상",
        "삽입 이상",
        "갱신 이상",
        "조회 이상"
      ],
      "examples": null,
      "answer_text": "조회 이상",
      "comment_text": "이상의 종류는 삽입 이상 삭제 이상(Insertion Anomaly), 갱신 이상 이렇게 (Deletion Anomaly), (Update Anomaly) 세 가지입니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 53,
      "subject": 3,
      "question_text": "SQL 구문에서 \"having\" 절은 반드시 어떤 구문과 사용되어야 하는가?",
      "options": [
        "GROUP BY",
        "ORDER BY",
        "UPDATE",
        "JOIN"
      ],
      "examples": null,
      "answer_text": "GROUP BY",
      "comment_text": "은 특정 속성을 기준으로 그룹화하여 검색할 때 그HAVING 룹에 대한 조건을 지정하는 절로 와 함께 사용합GROUP BY 니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 54,
      "subject": 3,
      "question_text": "뷰(View)에 대한 설명으로 가장 옳지 않은 것은?",
      "options": [
        "뷰는 독자적인 인덱스를 가질 수 없다.",
        "뷰는 논리적 독립성을 제공한다.",
        "뷰로 구성된 내용에 대한 삽입, 갱신, 삭제 연산에는 제약이 따른다.",
        "뷰를 제거할 때는 DELETE 문을 사용한다."
      ],
      "examples": null,
      "answer_text": "뷰를 제거할 때는 DELETE 문을 사용한다.",
      "comment_text": "뷰를 정의할 때는 문 제거할 때는 문을 사용CREATE , DROP 합니다. 회3 - 9 -"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 55,
      "subject": 3,
      "question_text": "학생(STUDENT) 테이블에 전산과 학생이 50명, 전자과 학생이 100명, 기계과 학생이 50명 있다고 할 때, 다음 SQL문 ㉠, ㉡, ㉢의 실행 결과 튜플 수는 각각 얼마인가? (단, DEPT 필드는 학과명을 의미한다.)",
      "options": [
        "㉠ 3, ㉡ 3, ㉢ 1",
        "㉠ 200, ㉡ 3, ㉢ 1",
        "㉠ 200, ㉡ 3, ㉢ 50",
        "㉠ 200, ㉡ 200, ㉢ 50"
      ],
      "examples": "㉠ SELECT DEPT FROM STUDENT;\n㉡ SELECT DISTINCT DEPT FROM STUDENT;\n㉢ SELECT COUNT(DISTINCT DEPT) FROM STUDENT\n   WHERE DEPT='전산과';",
      "answer_text": "㉠ 200, ㉡ 3, ㉢ 1",
      "comment_text": "의 튜플 수는 개 의 튜플 수는 개 의 튜플 수는 200 , 3 , ㉠ ㉡ ㉢ 개입니다1 . 테이블에서 를 검색합니다 총 개의 STUDENT DEPT . 200㉠ 튜플이 들어 있고 검색 조건이 없으므로 개의 튜플이 200 검색됩니다. 테이블에서 를 검색하는 데 중복된 결STUDENT DEPT㉡ 과는 처음의 한 개만 검색에 포함시킵니다 전산과 개 . 50 튜플의 속성의 값이 같으므로 개 전자과 개 DEPT 1 , 100 튜플의 속성의 값이 같으므로 개 기계과 개 DEPT 1 , 50 튜플의 속성의 값이 같으므로 개를 검색에 포함DEPT 1 시키므로 개의 튜플이 검색됩니다3 . 테이블에서 속성의 값이 전산과 인 STUDENT DEPT ‘ ’㉢ 튜플의 중복을 제거하여 개수를 세므로 개의 튜플이 검1 색됩니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 56,
      "subject": 3,
      "question_text": "릴레이션의 기본키를 구성하는 어떤 속성도 널(Null) 값이나 중복 값을 가질 수 없음을 의미하는 것은?",
      "options": [
        "참조 무결성 제약 조건",
        "정보 무결성 제약 조건",
        "개체 무결성 제약 조건",
        "주소 무결성 제약 조건"
      ],
      "examples": null,
      "answer_text": "개체 무결성 제약 조건",
      "comment_text": "릴레이션의 기본키를 구성하는 어떤 속성도 널 값이나 (Null) 중복 값을 가질 수 없음을 의미하는 것은 개체 무결성 제약 조건입니다. ㆍ참조 무결성(Referential Integrity)외래키 값은 이 : Null 거나 참조 릴레이션의 기본키 값과 동일해야 함 즉 릴레이. 션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정"
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 57,
      "subject": 3,
      "question_text": "A → B 이고 B → C 일 때 A → C를 만족하는 종속 관계를 제거하는 정규화 단계는?",
      "options": [
        "1NF → 2NF",
        "2NF → 3NF",
        "3NF → BCNF",
        "비정규 릴레이션 → 1NF"
      ],
      "examples": null,
      "answer_text": "2NF → 3NF",
      "comment_text": "이고 일때 를 만족하는 종속 관계는 A B B C A C → → → 이행적 종속 관계입니다."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 58,
      "subject": 3,
      "question_text": "릴레이션 R의 튜플의 개수가 4, 릴레이션 S의 튜플의 개수가 5일 때, 두 릴레이션을 카티션 프로덕트(Cartesian Product)한 결과 릴레이션의 카디널리티는?",
      "options": [
        "1",
        "9",
        "20",
        "41"
      ],
      "examples": null,
      "answer_text": "20",
      "comment_text": "카티션 프로덕트 교차곱 는 두 릴레이(Cartesian Product, ) 션에 있는 튜플들의 순서쌍을 구하는 연산으로 두 릴레이션, 의 차수 속성의 수 는 더하고 카디널리티 튜플의 (Degree, ) , ( 수 는 곱하면 됩니다 그러므로 차수는 카디널리티) . 4+5 = 9, 는 입니다4×5 = 20 ."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 59,
      "subject": 3,
      "question_text": "데이터 조작문의 유형으로 옳바르지 않은 것은?",
      "options": [
        "SELECT~ FROM~ WHERE~",
        "INSERT ON~ VALUES~",
        "DELETE~ FROM~ WHERE~",
        "UPDATE~ SET~ WHERE~"
      ],
      "examples": null,
      "answer_text": "INSERT ON~ VALUES~",
      "comment_text": "는 대신 가 사용되어 INSERT ON INTO ‘INSERT INTO~ 형식으로 기술되어야 합니다VALUES~’ ."
    },
    {
      "sourceKey": "2024-3",
      "sourceSessionId": "5",
      "problem_number": 60,
      "subject": 3,
      "question_text": "개념 세계에서 표현된 각 개체와 개체 간의 관계들을 서로 독립된 2차원 테이블 즉 릴레이션으로 표현하며, 가장 널리 사용되는 데이터 모델은?",
      "options": [
        "개체형 데이터 모델",
        "관계형 데이터 모델",
        "계층형 데이터 모델",
        "네트워크형 데이터 모델"
      ],
      "examples": null,
      "answer_text": "관계형 데이터 모델",
      "comment_text": "개념 세계에서 표현된 각 개체와 개체 간의 관계들을 서로 독립된 차원 테이블로 표현하는 데이터 모델은 관계형 데이2 터 모델입니다."
    }
  ]
}