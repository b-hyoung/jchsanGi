[
  {
    "title": "정보시스템 기반 기술",
    "comments": [
      {
        "problem_number": 1,
        "comment": "상태 다이어그램(State Diagram)에 대한 설명입니다. ·순차 다이어그램(Sequence Diagram) : 상호 작용하는 시 스템이나 객체들이 주고받는 메시지를 표현 ·객체 다이어그램(Object Diagram) : 클래스에 속한 사물 (객체)들, 즉 인스턴스(Instance)를 특정 시점의 객체와 객 체 사이의 관계로 표현 ·유스케이스 다이어그램(Use Case Diagram) : 사용자의 요 구를 분석하는 것으로 기능 모델링 작업에 사용함"
      },
      {
        "problem_number": 2,
        "comment": "하둡(Hadoop)은 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫 폼으로, 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형 성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발된 자바 소프트웨어 프레임워크입니다."
      },
      {
        "problem_number": 3,
        "comment": "객체 다이어그램(Object Diagram)은 클래스에 속한 사물 (객체)들, 즉 인스턴스(Instance)를 특정 시점의 객체와 객 체 사이의 관계로 표현합니다. •4번은 클래스 다이어그램(Class Diagram)에 대한 설명입 니다."
      },
      {
        "problem_number": 4,
        "comment": "데이터 흐름 검사는 화이트박스 테스트의 종류이고, 나머지는 블랙박스 테스트의 종류입니다."
      },
      {
        "problem_number": 5,
        "comment": "애플리케이션 테스트는 소프트웨어의 개발 단계에 따라 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트로 분류됩니 다."
      },
      {
        "problem_number": 6,
        "comment": "FIFO는 준비상태 큐에 도착한 순서대로 작업을 수행하므로, 다음과 같은 순서로 수행됩니다. 진행 시간 0 0 3 3 도착실행 완료 P1 실행 시작 P2 1 2 3 도착대기 실행 10 7 실행 10 완료 시작 2 실행 3 P3 7 도착 대기 10 12 실행 완료 시작 17 5 P4 7 12 5 도착 대기 실행 실행 완료 시작 P5 6 11 도착 대기 17 3 20 20 실행 실행 완료 시작 평균 반환 시간은 (3+9+9+12+14)/5 = 9.4 시간이 됩니다."
      },
      {
        "problem_number": 7,
        "comment": "프로세스(Process)의 주요 3가지 상태는 준비(Ready), 실행 (Running), 대기(Wait, Block)입니다."
      },
      {
        "problem_number": 8,
        "comment": "파스-타(PaaS-TA)는 소프트웨어 개발 환경을 제공하기 위해 개발한 개방형 클라우드 컴퓨팅 플랫폼으로, 국내 IT 서비스 경쟁력 강화를 목표로 과학기술정보통신부와 한국 정보화진흥원이 연구개발(R&D)을 지원하였습니다. •③번은 스마트 그리드(Smart Grid)에 대한 설명입니다."
      },
      {
        "problem_number": 9,
        "comment": "공통된 속성과 연산을 갖는 객체의 집합으로, 객체의 일반적 인 타입(Type)을 클래스(Class)라고 합니다. ·객체(Object) : 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈 ·캡슐화(Encapsulation) : 데이터(속성)와 데이터를 처리하 는 함수를 하나로 묶는 것을 의미함 ·상속(Inheritance): 이미 정의된 상위 클래스(부모 클래스) 의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받 는 것"
      },
      {
        "problem_number": 10,
        "comment": "문제의 지문에 제시된 내용은 추상 클래스에 대한 설명입니 다."
      },
      {
        "problem_number": 11,
        "comment": "스탬프 결합도에서 자료 구조의 변화는 그것을 조회하는 모든 모듈은 물론, 실제로 조회하지 않는 모듈에 까지 영향을 미칩 니다."
      },
      {
        "problem_number": 12,
        "comment": "FCFS 스케줄링 기법은 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법이고 현재 헤드의 위치가 50 트 랙이므로 이동 순서는 '50 → 10 → 40→55 → 35' 순으로 진행됩니다. 그러므로 총 이동거리는 40 + 30 + 15 + 20 = 105입니다."
      },
      {
        "problem_number": 13,
        "comment": "데이터 전송에서 한 문자의 전송 시마다 스타트 비트와 스톱 비트를 삽입하여 전송하는 방식은 비동기식 전송 방식입니다."
      },
      {
        "problem_number": 14,
        "comment": "객체 지향 기법에서 객체가 메시지를 받아 실행해야 할 때 객체의 구체적인 연산을 정의한 것은 메소드(Method)입니다. · 인스턴스(Instance) : 하나의 클래스에 속하는 각각의 객체 ·메시지(Message) : 외부로부터 하나의 객체에 전달되는 메 소드(행위)의 요구 ·클래스(Class) : 두 개 이상의 유사한 객체들을 묶어서 하나 의 공통된 특성을 표현하는 요소"
      },
      {
        "problem_number": 15,
        "comment": "개체 타입은 사각형으로 표시합니다."
      },
      {
        "problem_number": 16,
        "comment": "아파치 하둡 기반의 분산 데이터 웨어하우스 프로젝트를 타조 (Tajo)라고 합니다. · 데이터 마이닝(Data Mining) : 데이터 웨어하우스에 저장된 데이터 집합에서 사용자의 요구에 따라 유용하고 가능성 있는 정보를 발견하기 위한 기법으로, 대량의 데이터를 분 석하여 데이터 속에 내재되어 있는 변수 사이의 상호관계를 규명하여 패턴화함으로써 효율적인 데이터 추출이 가능함 ·맵리듀스(MapReduce) : 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델로, 흩어져 있는 데 이터를 연관성 있는 데이터 분류로 묶는 Map 작업을 수행한 후 중복 데이터를 제거하고 원하는 데이터를 추출하는 Reduce 직업을 수행함 ㆍ스쿱(Sqoop): 하둡과 관계형 데이터베이스 사이에서 효율 적으로 데이터를 이관하고 변환해 주는 명령줄 인터페이스 애플리케이션"
      },
      {
        "problem_number": 17,
        "comment": "문제에 제시된 내용은 어댑터(Adapter) 패턴에 대한 설명입 니다. ·브리지(Bridge): 구현부에서 추상층을 분리하여, 서로 가 독립적으로 확장할 수 있도록 구성한 패턴 · 데코레이터(Decorator) : 객체 간의 결합을 통해 능동적 으로 기능들을 확장할 수 있는 패턴 ·퍼싸드(Facade) : 복잡한 서브 클래스들을 피해 더 상위 에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴"
      },
      {
        "problem_number": 18,
        "comment": "종점 호스트 사이의 데이터 전송을 다루는 계층으로 종점 간의 연결 관리, 오류제어와 흐름제어 등을 수행하는 계층은 전송 계층(Transport Layer)입니다. ·물리 계층(Physical Layer) : 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의함(RS-232C, X.21 등) · 표현 계층(Presentation Layer) : 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능을 함 ·응용 계층(Application Layer) : 사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스를 제공함(SMTP, FTP, TELNET 등)"
      },
      {
        "problem_number": 19,
        "comment": "HIPO의 3가지 패키지에는 가시적 도표(도식 목차), 총체적 도표(총괄 도표, 개요 도표), 세부적 도표(상세 도표)가 있습니 다."
      },
      {
        "problem_number": 20,
        "comment": "프로젝트 개발 비용은 소프트웨어 형상 관리의 관리 항목에 포함되지 않습니다."
      }
    ]
  },
  {
    "title": "프로그래밍 언어 활용",
    "comments": [
      {
        "problem_number": 21,
        "comment": "프레임워크의 특성에는 모듈화, 재사용성, 확장성, 제어의 역 흐름 등이 있습니다."
      },
      {
        "problem_number": 22,
        "comment": "프레임워크는 개발표준에 의한 모듈화로 인해 유지 보수가 용이합니다."
      },
      {
        "problem_number": 23,
        "comment": "모듈(Module)의 독립성을 높이려면 결합도(Coupling)는 약 하게, 응집도(Cohesion)는 강하게 해야 합니다."
      },
      {
        "problem_number": 24,
        "comment": "사용된 코드의 의미는 다음과 같습니다. public class Test { public static void main(String[] args) { int n = 17; n += 1; n -= 2; n *= 3; n /= 4; n%= 5; System.out.println(n); } } ● 정수형 변수 n을 선언하고 17로 초기화한다. (n=17) ② 'n = n + 1;'과 동일하다. n에 1을 더한 값을 n에 저장한다. (n=18) ③ 'n = n - 2;'와 동일하다. n에서 2를 뺀 값을 n에 저장한다. (n=16) ④ 'n = n * 3;'과 동일하다. n에 3을 곱한 값을 n에 저장한다. (n=48) ⑤ 'n = n / 4;'와 동일하다. n을 4로 나눈 값을 n에 저장한다. (n=12) ⑥ 'n = n % 5;'과 동일하다. n을 5로 나눈 나머지를 n에 저장 한다. (n=2) ● n의 값을 출력한 후 커서를 다음 줄의 처음으로 옮긴다. 결과 2"
      },
      {
        "problem_number": 25,
        "comment": "조건이 참인지 거짓인지 판단하고자 할 때 사용하는 데이터 타입은 불린 타입(Boolean Type)입니다."
      },
      {
        "problem_number": 26,
        "comment": "보기 중 객체지향 언어는 C++ 입니다. •C, COBOL, FORTRAN은 절차적 프로그래밍 언어에 속합 니다."
      },
      {
        "problem_number": 27,
        "comment": "기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악 할 수 있도록 작성하는 원칙은 추적성(Traceability)입니다. ·정확성 : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성해야 한다는 원칙 ·명확성 : 해당 기능을 이해할 때 중의적으로 해석되지 않도 록 명확하게 작성해야 한다는 원칙 완전성 : 시스템 구현을 위해 필요한 모든 것을 기술해야 한다는 원칙"
      },
      {
        "problem_number": 28,
        "comment": "인수로 주어진 한 문자를 화면에 출력하는 함수는 putchar() 입니다. gets(): 키보드로 문자열을 입력받아 변수에 저장하는 함 수로, [Enter]를 누르기 전까지를 하나의 문자열로 인식하 여 저장함 ·getchar(): 키보드로 한 문자를 입력받아 변수에 저장하는 함수 ·puts(): 인수로 주어진 문자열을 화면에 출력한 후 커서를 자동으로 다음 줄 앞으로 이동하는 함수"
      },
      {
        "problem_number": 29,
        "comment": "파일 포인터 변수가 가리키는 위치에서 데이터를 가져와 변수 에 저장하는 함수는 fscanf입니다. ·fprintf: 파일 포인터 변수가 가리키는 위치에 변수에 저장 된 데이터를 출력하는 함수 ·fopen: 파일을 메모리에 저장한 후 그 시작 주소를 반환하 는 함수 · fclose: 파일 포인터 변수가 사용중인 메모리를 해제하는 함수"
      },
      {
        "problem_number": 30,
        "comment": "Zeplin은 디자인 관련 협업 도구입니다."
      },
      {
        "problem_number": 31,
        "comment": "추상화는 불필요한 부분을 생략하고 객체의 속성 중 가장 중요 한 것에만 중점을 두어 개략화하는 것, 즉 모델화하는 것입니 다. •①번은 정보 은닉(Information Hiding)에 대한 설명입니다."
      },
      {
        "problem_number": 32,
        "comment": "문제에 제시된 내용은 대역폭 제한의 기능입니다."
      },
      {
        "problem_number": 33,
        "comment": "정수형 변수 a와 sum을 선언하고 0으로 초기화합니다. (a=0, sum=0) ② do~while문의 시작이다. 3~4번을 반복 수행합니다. ③ 'a = a + 1;'과 동일하다. a에 1을 더한다. (a=1) 4 'sum = sum + a;'와 동일하다. sum에 a의 값을 더합니다. (sum=1) ⑤ a가 10보다 큰 동안 3~4번을 반복 수행한다. a가 10보다 크지 않으므로 반복문을 벗어납니다. (a=1, sum=1)"
      },
      {
        "problem_number": 34,
        "comment": "일련의 처리 절차를 정해진 문법에 따라 순서대로 기술해 나가 는 언어는 절차적 프로그래밍 언어입니다."
      },
      {
        "problem_number": 35,
        "comment": "스크립트 언어는 코드를 읽고 해석해야 하므로 실행 속도가 느립니다."
      },
      {
        "problem_number": 36,
        "comment": "C언어에서 변수명은 대·소문자를 구분합니다."
      },
      {
        "problem_number": 37,
        "comment": "함수나 코드의 범위를 한정하는 블록 내에서 선언되는 변수는 자동 변수(Automatic Variable)입니다. · 외부 변수(External Variable) : 현재 파일이나 다른 파일에 서 선언된 변수나 함수를 참조(reference)하기 위한 변수 ·정적 변수(Static Variable) : 함수나 블록 내에서 선언되어 선언한 함수나 블록 내에서만 사용할 수 있는 내부 정적 변 수와, 함수 외부에서 선언되어 모든 함수에서 사용할 수 있 는 외부 정적 변수가 있음 · 레지스터 변수(Register Variable) : 자주 사용되는 변수의 처리속도를 높이기 위해 사용하는 기억 클래스로, 메모리가 아닌 CPU 내부의 저장장소를 기억영역으로 할당받는 변수"
      },
      {
        "problem_number": 38,
        "comment": "stdlib.h에 대한 설명으로 옳은 것은 ①번입니다. ·②번은 string.h, ③ stdio.h, ④번은 math.h에 대한 설명입 니다."
      },
      {
        "problem_number": 39,
        "comment": "화살표를 사용하여 논리적인 제어구조로 흐름을 표현하는 표 기법은 흐름도(Flowchart)입니다."
      },
      {
        "problem_number": 40,
        "comment": "정수형 변수 x, y를 선언하고, 각각 7과 0으로 초기화한다. ② x가 0보다 큰 동안 3~6번을 반복 수행한다. x는 후치 증가 연산자이므로 x>0 비교 후 x의 값이 1 감소한다. ③ x를 3으로 나눈 나머지가 0이면 4번을 수행하고, 아니면 ⑤번으로 이동한다. ④ 반복문의 처음인 2번으로 이동한다. 6 ‘y = y + 1;'과 동일하다. y의 값에 1을 누적시킨다. ⑥ y의 값을 출력한다. 결과 4 ※ 반복문 실행에 따른 변수의 변화는 다음과 같다. 반복횟수 x%3 X Y 7 0 1 6 0 2024 2 5 1 2 3 4 2 1 34 일련의 처리 절차를 정해진 문법에 따라 순서대로 기술해 나가 는 언어는 절차적 프로그래밍 언어입니다. 4 3 0 5 2 3 2 6 1 4 1 7 0 0 반복실행 안됨 -1"
      }
    ]
  },
  {
    "title": "데이터베이스 활용",
    "comments": [
      {
        "problem_number": 41,
        "comment": "삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들 과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘입니다. 즉 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾습니다. 초기 자료 : 83497 ● 1회전 : 83497 38497 → 두 번째 값 3을 첫 번째 값과 비교하여 첫 번째 자리에 삽입하고 8을 한 칸 뒤로 이동시킵니다. ② 2회전 : 38497 34897 ← 세 번째 값 4를 첫 번째, 두 번째 값과 비교하여 8자리에 삽입하고 8을 한 칸 뒤로 이동시킵니다. ③ 3회전 : 34897 → 34897 네 번째 값 9를 첫 번째, 두 번째, 세 번째 값과 비교합니다. 자리의 이동이 없습니다. ④ 4회전 : 34897 34789 → 다섯 번째 값 7을 처음부터 비교하여 8자리에 삽입하고 나머지를 한 칸씩 뒤로 이동시킵니다."
      },
      {
        "problem_number": 42,
        "comment": "이 문제는 문제의 자료가 각 보기의 순서대로 출력되는지 스택 을 이용해 직접 입·출력을 수행해 보면 됩니다. PUSH는 스 택에 자료를 입력하는 명령이고, POP는 스택에서 자료를 출 력하는 명령입니다. 먼저 ②번을 살펴볼게요. PUSH A PUSH B PUSH C POP C POP B PUSH D POP D 니다. POP A B C B B A A A A A D A A C CB CBD CBDA"
      },
      {
        "problem_number": 43,
        "comment": "②,③,④번은 물리적 설계 단계에서 수행하는 작업입니다."
      },
      {
        "problem_number": 44,
        "comment": "데이터베이스 설계 단계를 순서대로 나열하면 '요구 조건 분 석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현'입니 다."
      },
      {
        "problem_number": 45,
        "comment": "DBMS의 필수 기능에는 정의 기능(Definition Facility), 조작 기능(Manipulation Facility), 제어 기능(Control Facility)이 있습니다."
      },
      {
        "problem_number": 46,
        "comment": "일반적인 데이터 모델의 3가지 구성 요소는 구조, 연산, 제약 조건입니다."
      },
      {
        "problem_number": 47,
        "comment": "JOIN 조건에 '=' 조건이 아닌 나머지 비교 연산자를 사용하는 JOIN은 NON-EQUI JOIN입니다. • EQUI JOIN: JOIN 대상 테이블에서 공통 속성을 기준으로 '='(equal) 비교에 의해 같은 값을 가지는 행을 연결하여 결과를 생성하는 JOIN 방법 • SELF JOIN: 같은 테이블에서 2개의 속성을 연결하여 EQUI JOIN을 하는 JOIN 방법 ·CROSS JOIN(교차 조인) : 조인하는 두 테이블에 있는 튜플 들의 순서쌍을 결과로 반환하는 JOIN으로, 교차 조인의 결 과로 반환되는 테이블의 행의 수는 두 테이블의 행 수를 곱 한 것과 같음"
      },
      {
        "problem_number": 48,
        "comment": "한 릴레이션에는 똑같은 튜플이 중복되어서는 절대로 안되며, 모든 튜플은 서로 다른 값을 가져야 합니다."
      },
      {
        "problem_number": 49,
        "comment": "삽입(INSERT)문의 일반 형식은 'INSERT ~ INTO ~ VALUES ~'입니다."
      },
      {
        "problem_number": 50,
        "comment": "모든 튜플에 대한 유일성은 만족시키지만 최소성은 만족시키 지 못하는 키(Key)는 슈퍼키(Super Key)입니다. ·후보키(Candidate Key): 릴레이션을 구성하는 속성들 중 에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용할 수 있는 속성들을 말함 ·대체키(Alternate Key) : 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미함 · 외래키(Foreign Key) : 다른 릴레이션의 기본키를 참조하 는 속성 또는 속성들의 집합을 의미함"
      },
      {
        "problem_number": 51,
        "comment": "후위 표기란 연산자가 해당 피연산자 2개의 뒤(오른쪽)에 표 기되어 있는 것을 말합니다. 그러므로 연산 순서에 따라 피연 산자 2개와 연산자를 괄호로 묶은 다음 연산자를 해당 피연 산자 사이로 이동시켜 중위 표기식으로 변경한 후 계산하면 쉽습 니다. ● 피연산자 2개와 오른쪽으로 인접한 연산자 1개를 묶습니다. ((34*)(56*)+) ② 연산자를 피연산자 사이로 이동시킵니다. ((34*)(56*)+) ③ 계산을 합니다. 반면 ①번은 D 출력 후에 B를 출력해야 하는데, C를 출력하지 않고는 D를 출력할 수 없으므로 불가능합니다. PUSH A PUSH B PUSH C PUSH D POP D POP B(불가능) D C C C C B B B B B A A A A A A D"
      },
      {
        "problem_number": 52,
        "comment": "데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자 에게 알려주는 데이터 제어어는 COMMIT입니다. • ROLLBACK : 데이터베이스 조작 작업이 비정상적으로 종 료되었을 때 원래의 상태로 복구함 ·REVOKE: 데이터베이스 사용자의 사용 권한을 취소함 • SAVEPOINT : 트랜잭션 내에 ROLLBACK 할 위치인 저장 점을 지정함"
      },
      {
        "problem_number": 53,
        "comment": "연결 리스트(Linked List)는 노드들이 포인터로 연결되어 포 인터를 찾아가는 시간이 필요하므로 선형 리스트에 비해 검색 속도가 느립니다."
      },
      {
        "problem_number": 54,
        "comment": "시스템 카탈로그 자체도 테이블(시스템 테이블)로 구성되어 있어 일반 사용자도 SQL을 이용하여 내용을 검색해 볼 수 있습니다. 단, 수정은 불가능합니다."
      },
      {
        "problem_number": 55,
        "comment": "릴레이션에서 속성의 수와 튜플의 수를 의미하는 것으로 순서대로 옳게 짝지어진 것은? ①CARDINALITY, DEGREE, ② DOMAIN, DEGREE ③ DEGREE, CARDINALITY ④ DEGREE, DOMAIN"
      },
      {
        "problem_number": 56,
        "comment": "트리(Tree)에서 차수(Degree)는 가장 차수가 많은 노드의 차수입니다. 문제에 주어진 트리(Tree)에서 각 노드의 차수 는 A=2, B=1, C=2, E=2이므로 A, C, E 노드의 차수인 2가 트리의 차수입니다 터미널 노드(단말 노드)란 자식이 하나도 없는 노드를 말합 니다. 제시된 그림에서 자식이 없는 터미널 노드는 D, F, G, H로 총 4개입니다."
      },
      {
        "problem_number": 57,
        "comment": "제2차 정규형에서 제3차 정규형이 되기 위한 조건은 이행 함 수 종속 제거입니다."
      },
      {
        "problem_number": 58,
        "comment": "SQL문에서 DISTINCT의 의미는 검색 결과에서 레코드의 중 복을 제거하라는 의미로 중복된 레코드가 있으면 그 중 첫 번째 한 개만 검색하여 표시합니다."
      },
      {
        "problem_number": 59,
        "comment": "SELECT DISTINCT S-AGE FROM STUDENT; : STUDENT 테이블에서 'S-AGE'를 검색하는데 DISTINCT 옵션이 있으므로 중복된 결과는 처음의 한 개만 검색에 포함 시킵니다. 'S-AGE'의 값 중 10인 튜플이 10개이지만 1개, 19인 튜플이 35개이지만 1개, 20인 튜플이 5개이지만 1개 를 검색에 포함시킵니다. 결과는 3개의 튜플이 검색됩니다. • SELECT DISTINCT S-AGE FROM STUDENT WHERE S-AGE > 19;: STUDENT 테이블에서 'S-AGE' 속성의 값이 19 이상인 튜플을 검색하되 중복을 제거하므로 1개의 튜플만 검색됩니다."
      },
      {
        "problem_number": 60,
        "comment": "개체 무결성은 기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정입니다. ·①번은 도메인 무결성, ②번은 참조 무결성, ③번은 사용자 정의 무결성에 대한 설명입니다."
      }
    ]
  }
]