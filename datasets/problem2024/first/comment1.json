[
  {
    "title": "정보시스템 기반기술",
    "comments": [
      {
        "problem_number": 1,
        "comment": "SMTP(Simple Mail Transfer Protocol)는 전자 우편을 전송하는 프로토콜입니다."
      },
      {
        "problem_number": 2,
        "comment": "중앙에 마스터 파일 디렉터리가 있고, 그 아래에 사용자별로 서로 다른 파일 디렉터리가 있는 구조는 2단계 디렉터리 구조입니다. ·1단계(단일) 디렉터리 구조 : 가장 간단하고, 모든 파일이 하나의 디렉터리 내에 위치하여 관리되는 구조 ·트리 디렉터리 구조 : 하나의 루트 디렉터리와 여러 개의 종속(서브) 디렉터리로 구성된 구조 ·비순환(비주기) 그래프 디렉터리 구조 : 하위 파일이나 하위 디렉터리를 공동으로 사용할 수 있는 것으로, 사이클이 허용되지 않는 구조"
      },
      {
        "problem_number": 3,
        "comment": "프로세스는 비동기적 행위를 일으키는 주체입니다."
      },
      {
        "problem_number": 4,
        "comment": "소프트웨어 아키텍처 뷰에는 유스케이스 뷰, 논리적 뷰, 구현 뷰, 배포 뷰, 프로세스 뷰가 있습니다."
      },
      {
        "problem_number": 5,
        "comment": "사용자 인터페이스(UI)는 사용자가 쉽게 이해하고 편리하게 사용할 수 있도록 사용자 중심으로 설계되어야 합니다."
      },
      {
        "problem_number": 6,
        "comment": "②번은 어댑터(Adapter) 패턴에 대한 설명입니다."
      },
      {
        "problem_number": 7,
        "comment": "RR(Round Robin) 기법은 할당되는 시간이 클 경우 FCFS 기법과 같아집니다."
      },
      {
        "problem_number": 8,
        "comment": "FIFO는 준비상태 큐에 도착한 순서대로 작업을 수행하므로, 다음과 같은 순서로 수행됩니다. 진행 시간 0 0 4 4 작업 1 도착실행 완료 실행 시작 1 3 4 10 10 작업 2 도착 대기 실행 실행 시작 14 완료 1 실행 14 15 4 10 작업 3 도착 대기 실행 완료 시작 작업 4 8 7 도착 대기 15 7 실행 실행 시작 20 .. 평균 대기 시간: (0+3+10+7)/4 = 5시간"
      },
      {
        "problem_number": 9,
        "comment": "소프트웨어 아키텍처는 재사용이 가능하도록 설계해야 합니다. 소프트웨어 아키텍처 설계의 기본 원리 중 모듈화가 바로 재사용이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미합니다."
      },
      {
        "problem_number": 10,
        "comment": "결합도를 약한 것부터 강한 것 순으로 나열하면 '자료 결합도(Data Coupling) → 스탬프(검인) 결합도(Stamp Coupling) → 제어 결합도(Control Coupling) → 외부 결합도(External Coupling) → 공통(공유) 결합도(Common Coupling) → 내용 결합도(Content Coupling)'입니다."
      },
      {
        "problem_number": 11,
        "comment": "Fedora는 운영체제의 한 종류입니다. 자동화 도구에는 Ant, Maven, Gradle, Jenkins 등이 있습니다."
      },
      {
        "problem_number": 12,
        "comment": "UNIX 시스템에서 파일의 권한 모드 설정에 관한 명령어는 chmod입니다. ·cp: 파일을 복사함 ·ls: 현재 디렉터리 내의 파일 목록을 확인함 ·chown: 소유자를 변경함"
      },
      {
        "problem_number": 13,
        "comment": "소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동을 형상 관리라고 합니다."
      },
      {
        "problem_number": 14,
        "comment": "100Base-T는 고속 이더넷(Fast Ethernet)이라고도 불리는 이더넷의 고속 버전으로, CSMA/CD를 사용하며, UTP(Unshielded Twisted Pair) 케이블을 이용해 100Mbps의 속도로 데이터를 전송합니다."
      },
      {
        "problem_number": 15,
        "comment": "연산 P, V와 정수 변수를 이용하여 동기화 문제를 해결하는 것은 세마포어(Semaphore)입니다."
      },
      {
        "problem_number": 16,
        "comment": "파이프-필터 패턴에 대한 설명으로 옳은 것은 ③번입니다. ·①번은 피어-투-피어 패턴, ②번은 레이어 패턴, ④번은 모델-뷰-컨트롤러 패턴에 대한 설명입니다."
      },
      {
        "problem_number": 17,
        "comment": "문제의 설명은 Secure Coding에 대한 설명입니다. · 소프트웨어 개발 생명 주기(SDLC; Software Development Life Cycle): 소프트웨어 개발 방법론의 바탕이 되는 것으로, 소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 과정을 각 단계별로 나눈 것 · CLASP: Secure Software 사에서 개발하였으며, SDLC의 초기 단계에서 보안을 강화하기 위해 개발된 방법론 · OWASP(the Open Web Security Project, 오픈 웹 애플리케이션 보안 프로젝트) : 웹 정보 노출이나 악성 코드, 스크립트, 보안이 취약한 부분을 연구하는 비영리 단체"
      },
      {
        "problem_number": 18,
        "comment": "실시간 전송이나, 대량의 데이터 전송에 가장 적합한 것은 회선 교환 방식입니다."
      },
      {
        "problem_number": 19,
        "comment": "접근 제어 행렬에서 수평으로 있는 각 행들만을 따온 것으로서 각 영역에 대한 권한은 객체와 그 객체에 허용된 연산자로 구성되는 것은 권한 리스트(Capability List)입니다. ·전역 테이블(Global Table) : 가장 단순한 구현 방법으로, 세 개의 순서쌍인 영역, 객체, 접근 권한의 집합을 목록 형태로 구성한 기법 ·접근 제어 리스트(Access Control List) : 접근 제어 행렬에 있는 각 열, 즉 객체를 중심으로 접근 리스트를 구성한 기법 ·록-키(Lock-Key) : 접근 제어 리스트와 권한 리스트를 절충한 기법으로, 각 객체는 Lock, 각 영역은 Key라 불리는 유일하고도 독특한 값을 갖고 있어서 영역과 객체가 일치하는 경우에만 해당 객체를 접근할 수 있음"
      },
      {
        "problem_number": 20,
        "comment": "가상기억장치는 보조기억장치의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법이다."
      }
    ]
  },
  {
    "title": "프로그래밍 언어 활용",
    "comments": [
      {
        "problem_number": 21,
        "comment": "사용된 코드의 의미는 다음과 같습니다. <html> <body> • <form method=\"post\" action=\"log01.jsp\"> 2 <p>아이디<input type=\"text\" name=\"id\"></p> 3 <p>암호<input type=\"password\" name=\"pw\"></p> 4 </form> </body> </html> 12~3번으로 입력받은 데이터를 Header와 Body에 첨부하여 'log01.jsp'로 전송한다. ·form: 사용자로부터 데이터를 입력받고 전송할 때 사용하는 태그 method: 데이터를 전송하는 방법을 명시하는 속성 post: 메시지의 Header와 Body에 데이터를 첨부하는 방식 get: URL에 데이터를 첨부하는 방식 action: 데이터가 도착할 URL을 표시하는 속성 ② “아이디” 이후에 문자열이 입력될 필드를 생성한다. 전송 후 데이터를 참조할 때 사용할 이름은 'id'이다. · input: 사용자로부터 입력을 받기 위한 요소들을 생성하는 태그 ·type: 생성할 요소의 종류 text: 텍스트를 입력받는 필드를 표시함 password: text와 동일하나 입력된 값이 '*'로 표시됨 submit : 클릭하면 form에 입력된 값들을 전송하는 단추를 표시함 ·name: form 태그를 통해 데이터가 전송된 후 해당 데이터를 참조하는 데 사용될 이름을 지정함 ③ “암호” 이후에 암호가 입력될 필드를 생성한다. 전송 후 데이터를 참조할 때 사용할 이름은 'pw'이다. ④ form 태그의 끝을 알리는 종료 태그이다."
      },
      {
        "problem_number": 22,
        "comment": "문제에서 설명하는 응집도는 논리적 응집도입니다. ·교환(통신)적 응집도(Communication Cohesion): 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도 ·순차적 응집도(Sequential Cohesion) : 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도 ·절차적 응집도(Procedural Cohesion): 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도"
      },
      {
        "problem_number": 23,
        "comment": "결합도를 약한 것부터 강한 것 순으로 나열하면 '자료 결합도(Data Coupling) → 스탬프(검인) 결합도(Stamp Coupling) → 제어 결합도(Control Coupling) → 외부 결합도(External Coupling) → 공통(공유) 결합도(Common Coupling) → 내용 결합도(Content Coupling)'입니다."
      },
      {
        "problem_number": 24,
        "comment": "C언어에서는 상수를 만들 때, #define [이름] [데이터] 또는 const [자료형] [이름] = [데이터]를 사용합니다."
      },
      {
        "problem_number": 25,
        "comment": "외부 변수는 함수가 종료되어도 기존에 저장된 값을 그대로 갖고 있습니다."
      },
      {
        "problem_number": 26,
        "comment": "사용된 코드의 의미는 다음과 같습니다. ……생략… <script> 1 var r = 0, i = 0; do { i = i + 1; if (i%7 == 0) { r = r + i; } } while (i < 1000); console.log(r); </script> ……생략… ● 변수 r과 i를 선언하고 모두 0으로 초기화한다. ② do~while 반복문의 시작점이다. 3~6번 문장을 반복 수행한다. ③ i의 값을 1씩 누적시킨다. ④ i를 7로 나눈 나머지가 0이면 6번으로 이동하고, 아니면 6번으로 이동한다. ⑤ r에 i의 값을 누적시킨다. ⑥ i가 1000보다 작은 동안 3~6번 문장을 반복 수행한다. ※ 반복문 실행에 따른 변수들의 값의 변화는 다음과 같다. r 0 i 0 1 2 : : 6 7 7 8 : : 14 21 : : 994 71071 995 996 997 998 999 1000 ● 콘솔에 r의 값을 출력한다. 결과 71071"
      },
      {
        "problem_number": 27,
        "comment": "자바스크립트에서 배열에 데이터를 추가할 때는 push()와 unshift() 메소드를 사용합니다."
      },
      {
        "problem_number": 28,
        "comment": "코드를 실행하면 노란색 배경을 갖는 셀은 3행이고, 사용된 코드의 의미는 다음과 같습니다. 1<html> ② <style> 3 tr:nth-child(even) { background-color: yellow; } 4 </style> 6 <body> 7 <table> <thead> <tr> <th></th> </tr> </thead> <tfoot> 13 <tr> <td></td> 15 </tr> 16 </tfoot> <tbody> 18 <tr> 19 <td></td> 20 </tr> 21 <tr> 22 <td></td> 23 </tr> 24 </tbody> 25 </table> </body> </html> HTML 문서는 태그(Tag)를 사용하여 브라우저에 나타날 웹 페이지를 구성합니다. 태그는 특정한 기능이나 모양 등을 정의하기 위한 '꼬리표'를 의미합니다. 예를 들어 제목(title)으로 '시나공'을 정의하고 싶다면, <title>시나공</title>으로 쓸 수 있습니다. '<title>'은 시작 태그, '/'가 들어간 '</title>'은 종료 태그에 해당합니다. 1, HTML 문서임을 알리는 시작점과 종료점이다. 1번부터 번까지의 문장이 HTML의 문법으로 작성되었음을 알 수 있다. <HTML>- ⑦~1에서 정의된 표 머리글의 첫 행 18~20에서 정의된 표 본문의 첫 행 2~16에서 정의된 표 바닥글의 첫 행 ②, ④ 스타일을 정의하는 태그의 시작점과 종료점이다. ②번부터 4번 사이에는 화면에 표시될 요소들의 모양, 색상 등 스타일에 대한 것이 정의된다. ③ 'tr'이라고 지정된 곳의 짝수 행에 노란색 배경을 지정한다. ·nth-child(): 특정 순번이나 홀수, 짝수 요소에만 스타일을 부여할 때 사용하는 속성, 여기서는 even이라고 하였으므로 짝수 요소에 대해서만 지정한 스타일이 적용된다. • background-color: yellow: backgrond-color는 배경 색을 의미하는 속성이고, yellow는 노란색을 의미한다. 6. 웹 페이지에 표시될 본문의 시작점과 종료점이다. 6번부터 번 사이에는 웹 페이지에 표시될 다양한 요소들이 정의된다."
      },
      {
        "problem_number": 29,
        "comment": "제곱근, 절대값 등을 구하기 위한 다양한 수학 함수는 math.h에 포함되어 있습니다. · stdio.h : 데이터의 입·출력에 사용되는 기능들을 제공함 · stdlib.h: 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기능들을 제공함 · time.h: 시간 처리에 사용되는 기능들을 제공함"
      },
      {
        "problem_number": 30,
        "comment": "①번은 상속(inheritance)에 대한 설명입니다."
      },
      {
        "problem_number": 31,
        "comment": "모듈 간의 결합도가 약할수록 바람직한 설계입니다."
      },
      {
        "problem_number": 32,
        "comment": "③번은 자식 클래스에 대한 설명입니다."
      },
      {
        "problem_number": 33,
        "comment": "문제의 그림은 JavaScript의 prompt('title', 'default') 명령문의 결과입니다."
      },
      {
        "problem_number": 34,
        "comment": "모듈은 독립성이 높을수록 좋은 모듈이라 할 수 있으며, 독립성을 높이려면 응집도는 강하고 결합도는 약해야 한다."
      },
      {
        "problem_number": 35,
        "comment": "·지문의 코드는 a가 b보다 크면 max에 a의 값을 저장하고, a가 b보다 크지 않으면 max에 b의 값을 저장하는 if문입니다. · 조건에 맞는 식은 ①번과 ②번이지만, 삼항 연산자의 각 항에는 삼항 연산자보다 우선순위가 높은 대입 연산자나 순서 연산자를 사용하지 못하므로 ①번이 답입니다."
      },
      {
        "problem_number": 36,
        "comment": "보기 중 C언어에서 변수명으로 사용할 수 있는 것은 iAvg입니다. ① 변수명의 첫 글자로 숫자를 사용할 수 없습니다. ② 예약어는 변수명으로 사용할 수 없습니다. ③ 변수명 중간에 공백을 사용할 수 없습니다."
      },
      {
        "problem_number": 37,
        "comment": "소프트웨어 개발이 있어 충족시켜야 할 3대 주요 보안 요소에는 기밀성(Confidentiality), 무결성(Integrity), 가용성(Availability)이 있습니다."
      },
      {
        "problem_number": 38,
        "comment": "지문의 연산 결과는 1입니다. ·연산자의 우선순위는 높은 것부터 차례대로 단항, 산술, 시프트, 관계, 비트, 논리, 조건, 대입, 순서 연산자 순이며, 관계 연산자 중에서 <, <=, >=, >는 ==, !=보다 우선순위가 높습니다. ·우선순위에 따라 문제의 식을 풀면 다음과 같습니다. a < b + 2 && a << 1 <= b 1 3 2 4 5 ① b+2: b의 값은 2이므로 결과는 4이다. ② a<<1: 왼쪽 시프트(<<)는 왼쪽으로 1비트 시프트 할 때마다 2배씩 증가하므로, a의 값 1을 왼쪽으로 1비트 시프트한 결과는 2이다. ③ a<a<4: a의 값 1은 4보다 작으므로 결과는 1(참)이다. ④ 2<=b→ 2<=b : b의 값 2는 2와 같으므로 결과는 1(참)이다. ⑤ 1&&1: &&은 모두 참일 때만 참이므로 결과는 1(참)이다."
      },
      {
        "problem_number": 39,
        "comment": "문제에서 설명하는 응집도는 논리적 응집도입니다. ·기능적 응집도(Functional Cohesion) : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도 ·순차적 응집도(Sequential Cohesion): 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도 ·절차적 응집도(Procedural Cohesion): 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도"
      },
      {
        "problem_number": 40,
        "comment": "Cobol은 절차적 프로그래밍 언어로 개발되었으나, 이후 객체 지향으로 변경된 컴파일 언어입니다."
      }
    ]
  },
  {
    "title": "데이터베이스 활용",
    "comments": [
      {
        "problem_number": 41,
        "comment": "INSERT는 데이터 조작어(DML)이고, CREATE, ALTER, DROP은 데이터 정의어(DDL)에 해당합니다."
      },
      {
        "problem_number": 42,
        "comment": "ㆍ교차곱을 의미하는 기호는 ×입니다. • U는 합집합, ∩는 교집합, -는 차집합을 의미하는 기호입니다."
      },
      {
        "problem_number": 43,
        "comment": "A→B이고 B→C 일때 A→C를 만족하는 종속 관계는 이행적 종속 관계입니다. 이행적 종속 관계를 제거하는 단계는 2NF → 3NF입니다."
      },
      {
        "problem_number": 44,
        "comment": "데이터베이스에서 두 릴레이션을 합병할 때 사용하는 연산자입니다. ·관계(비교) 연산자 : 두 수의 관계를 비교하여 참(true) 또는 거짓(false)을 결과로 얻는 연산자 ·논리 연산자 : 두 개의 논리 값을 연산하여 참(true) 또는 거짓(false)을 결과로 얻는 연산자"
      },
      {
        "problem_number": 45,
        "comment": "문제의 내용으로 SQL문으로 작성하면 다음과 같습니다. ·'학생' 테이블에서 ‘이름'만 조회하므로 SELECT 이름 FROM 학생입니다. · ‘3학년'이고 ‘컴퓨터공학과'인 학생을 대상으로 하므로 WHERE 학년 = 3 AND 학과 = “컴퓨터공학”; 입니다."
      },
      {
        "problem_number": 46,
        "comment": "관계대수는 질의에 대한 해를 생성하기 위해 수행해야 할 연산의 순서를 명시하는 절차적 언어입니다."
      },
      {
        "problem_number": 47,
        "comment": "SELECT, UPDATE, DELETE는 DML(데이터 조작어)입니다."
      },
      {
        "problem_number": 48,
        "comment": "한 릴레이션의 기본키를 구성하는 어떠한 속성 값도 널(Null) 값이나 중복 값을 가질 수 없다는 것을 의미하는 것은 개체 무결성 제약 조건입니다. ·참조 무결성 : 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정임 · 도메인 무결성 : 주어진 속성 값이 정의된 도메인*에 속한 값이어야 한다는 규정임"
      },
      {
        "problem_number": 49,
        "comment": "이상의 종류에는 삽입 이상, 삭제 이상, 갱신 이상이 있습니다."
      },
      {
        "problem_number": 50,
        "comment": "보조키는 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보 키를 의미한다."
      },
      {
        "problem_number": 51,
        "comment": "SQL에서 뷰(View)를 정의할 때 사용하는 명령은 CREATE, 삭제할 때 사용하는 명령은 DROP입니다."
      },
      {
        "problem_number": 52,
        "comment": "서로 다른 두 개 이상의 레코드가 같은 주소를 갖는 현상을 의미하는 것은 Collision(충돌 현상)입니다."
      },
      {
        "problem_number": 53,
        "comment": "시스템 카탈로그 자체도 테이블(시스템 테이블)로 구성되어 있어 일반 사용자도 SQL을 이용하여 내용을 검색해 볼 수 있습니다. 단, 수정은 불가능합니다."
      },
      {
        "problem_number": 54,
        "comment": "버블 정렬은 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식으로 다음과 같은 과정으로 진행됩니다. ·초기상태 : 9, 6, 7, 3, 5 · 1회전 : 6,9, 7, 3, 5→ 6, 7, 9, 3, 5 → 6, 7, 3, 9, 5 → 6, 7, 3, 5, 9 • 2회전 : 6,7, 3, 5, 9 → 6, 3, 7, 5, 9 → 6, 3, 5, 7, 9 • 3회전 : 3,6, 5, 7, 9 → 3, 5, 6, 7, 9 • 4회전 : 3,5, 6, 7, 9"
      },
      {
        "problem_number": 55,
        "comment": "데이터베이스에서 아직 알려지지 않거나 모르는 값으로서 “해당 없음” 등의 이유로 정보 부재를 나타내기 위해 사용하는 특수한 데이터 값을 무엇이라 하는가? 널 값(Null Value)이라고 합니다."
      },
      {
        "problem_number": 56,
        "comment": "WHERE절의 조건 중 NOT은 결과를 반대로 출력하는 논리 부정 연산자, LIKE는 지정된 문자를 포함하는 문자열을 찾는 연산자, _은 한 자리 문자를 대신하는 대표 문자입니다. • WHERE 절의 정확한 의미는 “박”으로 시작하지 않거나 박으로 시작하면서 3글자가 아닌 문자 이름을 검색한다.'이므로 보기 ④번의 내용은 여기에 포함된다고 할 수 있습니다. ·정리하자면 “박”으로 시작하지 않는 모든 이름을 검색한다. [예] 왕건, 김선길, 을지문덕 등 -“박”으로 시작하면서 3글자가 아닌 이름을 검색한다. [예] 박열, 박혁거세 등"
      },
      {
        "problem_number": 57,
        "comment": "개체-관계 모델의 E-R 다이어그램에서 속성을 의미하는 그래픽 표현은 타원입니다. ·사각형 : 개체(Entity) 타입 ·마름모 : 관계(Relationship) 타입"
      },
      {
        "problem_number": 58,
        "comment": "질의문 실행의 결과는 15000입니다. 문제의 질의문은 하위 질의가 있는 질의문입니다. 먼저 WHERE 조건에 지정된 하위 질의의 SELECT문을 검색합니다. 그리고 검색 결과를 본 질의의 조건에 있는 '책번호' 속성과 비교합니다. ● SELECT 책번호 FROM 도서 WHERE 책명 = '운영체제' : <도서> 테이블에서 '책명' 속성의 값이 '운영체제'와 같은 튜플의 '책번호' 속성의 값을 검색합니다. 결과는 1111입니다. ● SELECT 가격 FROM 도서가격 WHERE 책번호 = 1111; : <도서가격> 테이블에서 ‘책번호' 속성의 값이 1111과 같은 튜플의 '가격' 속성의 값을 검색합니다. 결과는 15000입니다."
      },
      {
        "problem_number": 59,
        "comment": "둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다는 것을 의미하는 트랜잭션의 특징은 Isolation(독립성)입니다. ·Atomicity(원자성): 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 함 • Consistency(일관성) : 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함 ·Durability(영속성, 지속성) : 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함"
      },
      {
        "problem_number": 60,
        "comment": "삽입과 삭제가 리스트의 양쪽 끝에서 발생할 수 있는 자료 구조는 데크(Deque)입니다. ㆍ스택(Stack): 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조로, 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO; Last In First Out) 방식으로 자료를 처리함 ㆍ큐(Queue): 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조로, 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO; First In First Out) 방식으로 처리함"
      }
    ]
  }
]