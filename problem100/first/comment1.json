[
  {
    "title": "1과목 소프트웨어 설계",
    "comments": [
      {
        "problem_number": 1,
        "comment": "Requirements Validation(요구사항 검증)\n - 실제로 고객이 원하는 바를 정의했는지를 보이는 것\n - 검증이 중요한이유는 시스템을 개발하거나, 시스템이 운영 중일 경우에 발견되면 방대한 재 작업 비용이 발생된다.\n - 시스템을 변경하여 요구사항 문제를 수정하는 비용은 설계및 코딩오류에 비하여 비용이 많이 소요된다.\n (시스템 설계 및 구현 변경 및 다시 테스트해야하기 때문)\n\nRequirements Checklist(요구사항 체크리스트)\n유효성(Validity): 고객의 필요를 충족하는 기능을 제공하는지(요구한것이 맞는지)\n일관성(Consistency): 충돌하는 요구사항이 존재하는지(ex.모순되는 제약조건)\n완결성(Completeness): 고객이 요구한 모든 기능이 포함되었는지\n현실성(Realism): 예산과 기술적으로로 실행 가능한지(일정 또한 포함)\n검증 가능성(Verifiability): 만들고 난 뒤 요구사항들을 검증할 수 있는지(요구사항과 일치여부)\n\n>> 요구사항 검증 과정을 통해 모든 문제점을 발견할 수는 없다.\n[해설작성자 : 한비로]\n\n일관성(Consistency): 충돌하는 요구사항이 존재하는지(ex.모순되는 제약조건)\n[해설작성자 : comcbt.com 이용자]"
      },
      {
        "problem_number": 2,
        "comment": "MOM(Message Oriented Middleware)\n- 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어이다.\n- 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용한다.\n[해설작성자 : 두목넷]\n\nMOM(Message Oriented Middleware)은 ﻿즉각적인 응답을 원하는 경우가 아니라 다소 느리고 안정적인 응답을 필요로 하는 경우에 많이 사용됩니다.\n[해설작성자 : 세유니에용]"
      },
      {
        "problem_number": 3,
        "comment": "클래스\n- 객체지향 프로그램에서 데이터를 추상화하는 단위이다.\n- 공통된 속성과 연산(행위)를 갖는 객체의 집합.\n\n메소드\n- 객체의 메소드는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행한다.\n\n상속성\n- 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것이다.\n소프트웨어의 '재사용'을 높이는 중요한 개념.\n\n메시지\n- 객체들 간의 상호작용을 하는 데 사용되는 수단으로, 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구사항이다.\n[해설작성자 : 돌밍이]"
      },
      {
        "problem_number": 4,
        "comment": "message는 객체에게 어떤 행위를 하도록 지시하는 명령(11번과 같은 문항)\nmethod는 객체에 소속된 함수를 의미\nmodule은 실행코드와 객체들(함수, 클래스, 변수)의 묶음\n[해설작성자 : 컴린이]"
      },
      {
        "problem_number": 5,
        "comment": "캡슐화를 통하여 정보은닉 가능\n[해설작성자 : .]"
      },
      {
        "problem_number": 6,
        "comment": "자료흐름도 4가지 구성요소\n - 처리 Process : 원\n - 자료흐름 Data Flow : 화살표\n - 자료저장소 Data Store : 평행선\n - 단말 Terminal : 사각형\n[해설작성자 : 양기모띄]"
      },
      {
        "problem_number": 7,
        "comment": "*코드 정의:\n데이터를 사용 목적에 따라 식별, 분류, 배열하기 위하여 사용되는 숫자, 문자 또는 기호로 컴퓨터 처리에 효율적인 것을 선정\n*코드 종류\n1) 순차 코드(Sequence Code)-자료의 발생순, 크기순, 가나다순 등 일정 순서대로 코드\n2) 블록 코드(Block Code : 구분 코드)- 코드화 대상을 미리 파악하여 블록으로 구분한 후 그 안에서 순서대로 코드를 부여\n3) 그룹 분류 코드(Group Classification Code)-구분 코드를 세분화한 형태로 대분류, 중분류, 소분류 등 각 분류별로 자릿수를 구성\n4) 표의 숫자 코드(Significant Digit Code)-표현하려는 대상의 의미는 제외하고 수치만을 모아 만든 것으로 대상이 되는 물체의 중량, 면적, 크기 등을 직접 코드에 적용\n5) 십진 분류 코드(Decimal Classification Code)-코드화 대상물을 일정한 소속으로 구분하여 십진수 한 자리씩 구분하여 대분류하고, 같은 방법으로 중 분류, 소분류한 코드\n6) 연상 코드(Mnemonic Code)-숫자나 문자를 조합해서 나타내는 것으로 어떤 내용을 기억할 수 있도록 표시한 기호 코드\n7) 약자 코드(Letter Code)-일반적으로 사용해온 단위의 약자를 코드로 사용\n8) 끝자리 분류 코드(Final Digit Code)-다른 종류의 코드와 조합해서 사용하며, 코드의 끝에 붙여서 그 의미를 표현\n=============\n#20년 2회 2번(일련번호-순차코드)\n[해설작성자 : 저질체력]"
      },
      {
        "problem_number": 8,
        "comment": "모듈 F를 제어하는 수는 B,C,D 총 3개(fan-in)\n모듈 F가 제어하는 수는 G,H 총 2개(fan-out)\n[해설작성자 : 퇴근하고 싶다]"
      },
      {
        "problem_number": 9,
        "comment": "사용자 인터페이스(UI)의 기본 원칙\n- 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 함\n- 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함\n- 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 함\n- 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함\n[해설작성자 : ㅇㅎㅅ]"
      },
      {
        "problem_number": 10,
        "comment": "코드(Code)의 주요 기능\n- 식별 기능 : 데이터 간의 성격에 따라 구분\n- 분류 기능 : 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화\n- 배열 기능 : 의미를 부여하여 나열\n- 표준화 기능 : 다양한 정보를 컴퓨터에 의해 처리하기 위해서는 단일한 형태의 표준화된 표현이 필요함\n[해설작성자 : ㅇㅎㅅ]"
      },
      {
        "problem_number": 11,
        "comment": "XP(eXtreme Programming)의 5가지 가치\n\n용기(Courage) : 고객의 요구사항 변화에 능동적인 대처\n단순성(Simplicity) : 부가적 기능, 사용되지 않는 구조와 알고리즘 배제\n커뮤니케이션(Communication) : 개발자, 관리자, 고객 간의 원활한 의사소통\n피드백(Feedback) : 지속적인 테스트와 반복적 결함 수정, 빠른 피드백\n존중(Respect) : 모든 프로젝트 관리자는 팀원의 기여를 존중\n[해설작성자 : 만지]"
      },
      {
        "problem_number": 12,
        "comment": "상위 설계 : 아키텍처 설계, 데이터 설계, 시스템 분할, 인터페이스 정의, 사용자 인터페이스 설계(UI 설계)\n\n하위 설계 : 모듈 설계, 인터페이스 작성\n[해설작성자 : 도라예몽]"
      },
      {
        "problem_number": 13,
        "comment": "럼바우는 객체 모델링, 동적 모델링, 기능 모델링 : 객동기\n추가로 동적 모델링-상태도, 기능 모델링-자료 흐름도 : 동상기자\n로 암기\n[해설작성자 : 한개때문에 불합이라니]"
      },
      {
        "problem_number": 14,
        "comment": "일반화 관계\n- 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현함\n- 일반적인 개념을 상위(부모), 구체적인 개념을 하위(자식)이라고 함\n- 하위 사물에서 상위 사물인 쪽으로 속이 빈 화살표를 연결함\n[해설작성자 : ㅇㅎㅅ]"
      },
      {
        "problem_number": 15,
        "comment": "정형 명세법\n - 수학적 기반/모델링 기반\n - Z, VDM, Petri-Net(모형기반)\n - CSP, CCS, LOTOS(대수적방법)\n - 시스템 요구특성이 정확하고 명세가 간결하다. 명세와 구현이 일치.\n - 그러나 이해도가 낮으며 이해관계자의 작성 부담 가중.\n\n비정형명세\n - 상태, 기능, 객체 중심 명세법\n - FSM(Finite state machine)\n - Decision Table, ER모델링\n - State chart(SADT)\n - UseCase : 사용자기반모델링\n - 명세 작성이 간편하고 의사전달 방법이 다양하다.\n - 불충분한 명세가능성, 모호성.\n[해설작성자 : paraeism]\n\n요구사항 명세 기법은 정형 명세와 비정형 명세로 나뉜다.\n정형 명세기법의 특징\n1. 수학적 기호, 정형화된 표기법으로 작성\n2. 정확하고 간결하게 표현할 수 있지만 표기법이 어려워 사용자가 이해하기 어렵다.\n3. 일관성이 있다.\n\n비정형 명세기법의 특징\n1. 일반 명사, 동사 등의 자연어를 기반으로 작성한다.\n2. 이해가 쉽다.\n3. 일관성이 떨어진다.\n[해설작성자 : 돌밍이]"
      },
      {
        "problem_number": 16,
        "comment": "CASE: 시스템 개발과정의 일부 또는 전체를 자동화시킨 것\n- 소프트웨어 생명주기의 전체 단계를 연결해 주고 자동화해주는 통합된 도구를 제공\n- 소프트웨어, 하드웨어, 데이터베이스, 테스트 등을 통합하여 소프트웨어를 개발하는 환경을 제공\n\n상위 CASE: 요구 분석과 설계 단계를 지원\n- 모델들 사이의 모순검사 기능\n- 모델의 오류 검증 기능\n- 자료흐름도 작성 기능\n\n하위 CASE: 코드를 작성하고 테스트하며 문서화하는 과정 지원\n- 원시코드 생성 기능\n\n통합 CASE: 소프트웨어 개발 주기 전체과정을 지원\n[해설작성자 : 컴린이]"
      },
      {
        "problem_number": 17,
        "comment": "객체지향 설계원칙\n\n1. 단일 책임 원칙(SRP, Single Responsibility Principle)\n객체는 단 하나의 책임만 가져야 한다.\n\n2. 개방-폐쇄의 원칙(OCP, Open Closed Principle)\n기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.\n\n3. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)\n일반화 관계에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.\n\n4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)\n인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다.\n\n5. 의존 역전 원칙(DIP, Dependency Inversion Principle)\n의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것.\n[해설작성자 : dang]"
      },
      {
        "problem_number": 18,
        "comment": "Rumbaugh(럼바우) 방법\n모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법으로, 객체 모델링 기법(Object Modeling Technique) 라고도 한다. 분석활동은 객체모델링 -> 동적 모델링 -> 기능 모델링 순으로 통해 이루어진다\n\nBooch(부치) 방법\n미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법으로, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의한다.\n\nJacobson 방법\nUse Case를 강조하여 사용하는 분석 방법이다.\n\nCoad와 Yourdon 방법\nE-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법\n\nWirfs-Brock 방법\n분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법\n[해설작성자 : ham]"
      },
      {
        "problem_number": 19,
        "comment": "GoF(Gangs of Four) 디자인 패턴 분류\n1. 생성 패턴\n2. 구조 패턴\n3. 행위 패턴\n\n- 추상 패턴은 없고, 생성 패턴으로 추상 팩토리가 있다. (헷갈리지 말기)\n[해설작성자 : 손절왕 서서]"
      },
      {
        "problem_number": 20,
        "comment": "편의성을 높임으로써 작업시간을 '단축'시킨다\n[해설작성자 : 유녀기]"
      }
    ]
  },
  {
    "title": "2과목 소프트웨어 개발",
    "comments": [
      {
        "problem_number": 21,
        "comment": "상향식 통합 테스트 (Bottom Up Integration Test)\n - 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합\n - 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터(Cluster)필요\n하향식 통합 테스트 (Top Down Integration Test)\n - 상위 모듈에서 하위 모듈 방향으로 통합\n - 깊이 우선 통합법, 넓이 우선 통합법 사용\n - 초기부터 사용자에게 시스템 구조를 보여줌\n[해설작성자 : 전자공학도]\n\n상향식 테스트 : 드라이버(Driver) 이용(하위 모듈 호출, 매개변수 전달, 테스트 후 결과 도출)\n하향식 테스트 : 스텁(Stub) 이용(모듈 기능만 수행)\n[해설작성자 : 공부하자]"
      },
      {
        "problem_number": 22,
        "comment": "테스트 스텁 - 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈\n테스트 슈트 - 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합\n테스트 케이스 - 사용자의 요구사항을 정확히 준수했는지 확인하기 위한 입력 값, 실행조건, 기대결과 등으로 만들어진 테스트 항목의 명세서\n[해설작성자 : 김라마]\n\n스텁(stub)은 하향식\n드라이버(driver)는 상향식\n[해설작성자 : 사는게힘들다]"
      },
      {
        "problem_number": 23,
        "comment": "소프트웨어 품질측정 개발자 관점\n 정확성, 신뢰성, 효율성, 무결성, 유연성, 이식성, 사용성, 상호운용성\n[해설작성자 : 거상 주작섭]\n\n무결성,신뢰성,사용성,효율성,정확성,이식성,상호 운용성\n무신사 (에서) 효정 (이라는 애가 옷을 샀는데) 이상 (하다.)\n[해설작성자 : 알비노]"
      },
      {
        "problem_number": 24,
        "comment": "전위 표기법(prefix)-연산자가 앞에\n중위 표기법(infix)-연산자가 안에\n후위 표기법(postfix)-연산자가 뒤에\n\n1.연산자에 따라 묶는다\n(-(/(*A(+BC))D)E)\n\n2.연산자를 각 괄호 뒤로 뺀다(후위식)\n(((A(BC)+)*D)/E)-\n\n3.괄호를 제거한다.\nABC+*D/E-\n[해설작성자 : 또르링]\n\n전위식 -> 중위식 -> 후위식\n\n1. -/*A+BCDE 전위식\n2. -/*A(B+C)DE\n -/(A*(B+C))DE\n -((A*(B+C))/D)E\n ((A*(B+C))/D)-E 중위식\n3. (A*BC+/D)-E\n (ABC+*/D)-E\n (ABC+*D/)-E\n ABC+*D/E- 후위식\n\n[해설작성자 : 루니]"
      },
      {
        "problem_number": 25,
        "comment": "EAI 구축 유형 : 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달 연계 통합등 상호연동이 가능하게 해주는 솔루션 // 그림 확인해야함\n Point - to - Point : 가장 기본적인 애플리케이션 통합 방식 1:1로 연결\n Hub & Spoke : 단일 접점인 허브 시스템을 통해 데이터 전송하는 중앙 집중형 방식\n Message Bus : 애플리케이션 사이에 미들웨어를 두어 처리하는 방식\n Hybrid : Hub & Spoke 와 Message Bus 혼합 방식\n[해설작성자 : 거상 주작섭]"
      },
      {
        "problem_number": 26,
        "comment": "-단위 테스트 종류-\n명세 기반 테스트: 주어진 명세를 빠짐없이 테스트 케이스로 구현하고 있는지 확인하는 테스트\n구조 기반 테스트: 프로그램 내부 구조 및 복잡도를 검증하는 화이트박스 테스트 시행, 제어 흐름과 조건 결정 등이 목적\n[해설작성자 : 컴린이]\n\n4. 성능 테스트 도구(Performance Test Tools) : 애플리케이션의 처리량, 응답시간, 경과시간, 자원 사용률 등 성능 목표 달성 여부 확인\n- 인위적으로 적용한 가상 사용자를 만들어 테스트 수행\n[해설작성자 : comcbt.com 이용자]"
      },
      {
        "problem_number": 27,
        "comment": "Overflow(오버플로우) : 스택 공간이 가득찼을 때 하나의 데이터를 더 넣으려고 하는 경우, 스택 오버플로우가 일어나고 프로그램에 오류 야기\n\nUnderflow(언더플로우) : 스택 공간에 데이터가 없는데 프로그램에서 스택에서 데이터를 꺼내려고 하는 경우, 스택 언더플로우가 일어나며 프로그램에 오류를 야기\n[해설작성자 : 나풀너풀(나도풀었으니너도풀수있어)]\n\n4. Top = Top\n먼저 IF Top = 0문을 통해 스택이 비어있을 경우만 따로 처리함으로 언더플로우 상황에 진입하지 않는다.\n굳이 명시하지 않아도 되지만, Top = Top을 통해 여전히 스택이 비어있음을 명시한다.\n[해설작성자 : 당일치기]"
      },
      {
        "problem_number": 28,
        "comment": "사용자 매뉴얼 준비 절차\n작성 지침 정의 -> 사용자 매뉴얼 구성 요소 정의 -> 구성 요소별 내용 작성 -> 사용자 매뉴얼 검토\n\n설치와 사용에 필요한 제반 절차 및 환경 등 전체 내용을 포함하는 매뉴얼을 작성해야 합니다.\n[해설작성자 : ㄱㄱㅇ]\n\n구성요소를 먼저 정의하고 -> 구성요소 내용을 작성 -> 검토\n[해설작성자 : 막내아들]"
      },
      {
        "problem_number": 29,
        "comment": "1. 신뢰성 - 소프트웨어가 요구된 기능을 정확하고 일관되게 오류없이 수행할 수 있는 정도\n2. 유지보수성 - 환경의 변화 또는 새로운 요구사항이 발생했을 때 소프트웨어를 개선하거나 확장할 수 있는 정도\n3. 가시성 - 대상을 확인할 수 있는 정도\n[해설작성자 : 또르링]"
      },
      {
        "problem_number": 30,
        "comment": "리스트, 스택, 큐, 데크 → 선형\n트리, 그래프 → 비선형\n[해설작성자 : 수박]"
      },
      {
        "problem_number": 31,
        "comment": "선형 검색 - 처음부터 끝까지 하나씩 순서대로 비교하며 원하는 값을 찾아내는 검색\n[해설작성자 : 전자공학도]\n\n이진검색 - 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.\n[해설작성자 : 문은식]\n\n검색 알고리즘\n - 선형 검색(Linear Search) : 데이터가 모인 집합(배열, 리스트 등)의 처음부터 끝까지 하나씩 순서대로 비교하며 검색(순차검색)\n - 이진 검색(Binary Search) : 데이터가 오름차순 혹은 내림차순으로 정렬된 배열에서 검색하는 알고리즘(이분 검색)\n[해설작성자 : 공부하자]"
      },
      {
        "problem_number": 32,
        "comment": "3은 피보나치 검색에 대한 설명.\n이진 검색은 전체 파일을 두 개의 서브파일로 분리해가면서 key 레코드를 검색하는 방식\n[해설작성자 : 첫트합격 가즈아]"
      },
      {
        "problem_number": 33,
        "comment": "가 - 사전교육\n나 - 준비\n다 - 인스펙션 회의\n라 - 수정\n마 - 후속조치\n[해설작성자 : ㅎㅎ]"
      },
      {
        "problem_number": 34,
        "comment": "EAI (Enterprise Application Integration)\n기업 내 상호 연동이 가능하게 해주는 솔루션\n\n비즈니스 간 통합 및 연계성을 증대시켜 각 시스템 간의 확정성을 높여줌\n\n-구축 유형-\n\nPoint-to-Point\n가장 기본적인 애플리케이션 통합 방식으로, 애플리케이션을 1:1 로 연결\n변경 및 재사용이 어려움\n\nHub & Spoke\n단일 접점인 허브를 통해 데이터를 전송하는 중앙 집중형 방식\n확장 및 유지 보수가 용이하지만 허브 장애 발생 시 시스템 전체에 영향\n\nMessage Bus (ESB 방식)\n애플리케이션 사이에 미들웨어를 두어 처리하는 방식\n확장성이 뛰어나며 대용량 처리가 가능\n\nHybrid\n그룹 내에서는 Hub & Spoke 방식, 그룹 간에는 Message 방식 사용\n데이터 병목 현상 최소화\n[해설작성자 : 합격 가즈아!~~`]"
      },
      {
        "problem_number": 35,
        "comment": "스택연산 : 입구 및 출구가 하나 A B C D 순으로 입력되었을때 출력순서는 D C B A 순\npush 입력 pop 출력\npush A\npush A B\npop_ A / B\npush A C / B\npush A C D / B\npop_ A C / B D\npop_ A / B D C\npop_ / B D C A\n[해설작성자 : .]"
      },
      {
        "problem_number": 36,
        "comment": "chief programmer team은 형상관리를 위해 구성된 팀을 뜻하지 않음\n[해설작성자 : 또르링]\n\nchief programmer team : 효율성을 제고하기 위하여 능력과 경험이 풍부한 책임 프로그램 작성자를 중심으로 하여 구성한 개발 팀.\n[해설작성자 : 배고프다]\n\n형상관리를 위하여 구성된 팀을 형상통제위원회(CCB; Change Control Board)라고 함\n[해설작성자 : 총정리]"
      },
      {
        "problem_number": 37,
        "comment": "최악의 경우에서 검색 시간복잡도\n-이진 탐색트리: O(n)\n-AVL트리: O(log n)\n-2-3트리: O(log 3n)\n-레드 블랙 트리: O(log n)\n[해설작성자 : 자료구조와알고리즘]"
      },
      {
        "problem_number": 38,
        "comment": "소프트웨어의 최종 소비자는 End User이기 때문에 End User의 요구사항을 최대한으로 반영해서 소프트웨어를 개발해야한다.\n또한 소프트웨어의 인터페이스는 End User의 수준에 맞게 직관적이고 사용하기 쉽게 설계, 개발되어야 한다.\n[해설작성자 : 너의목소리]"
      },
      {
        "problem_number": 39,
        "comment": "코드 인스펙션\n - 결함 뿐만 아니라 모든 것이 표준대로 되어 있는 지 확인하기 위한 검토\n - 표준이나 명세서에 서술한 내용과 비교하여 편차와 에러를 식별하기 위해 산출물을 근거로 수행하는 검사\n - 정적 테스트에 가까움\n[해설작성자 : 강썬]"
      },
      {
        "problem_number": 40,
        "comment": "외계인코드 : 외계인 → 없는 존재 = 코드에 대해 아는 사람이 없음 → 유지 보수 어려움\n[해설작성자 : 거상 주작섭]\n\n스파게티 코드 : 프로그램의 로직이 복잡하여 이해하기 어려운 프로그램을 의미한다.\n→나쁜코드, 코드의 로직이 얽혀 스파게티 코드라고도 함.\n[해설작성자 : 자몽자몽]"
      }
    ]
  },
  {
    "title": "3과목 데이터베이스 구축",
    "comments": [
      {
        "problem_number": 41,
        "comment": "\"SELECT * FROM 공급자 WHERE 공급자명\" 까지는 동일합니다.\n공급자명이 NULL인 값은 없으니 제거하고\nLIKE \"%value%\"\nvalue에 공통적으로 들어갈 문자를 찾아주면 되겠습니다.\n[해설작성자 : 김태환]\n\n아래와 같은 오류 신고가 있었습니다.\n여러분들의 많은 의견 부탁 드립니다.\n추후 여러분들의 의견을 반영하여 정답을 수정하도록 하겠습니다.\n참고로 정답 변경은 오류 신고 5회 이상일 경우 수정합니다.\n\n[오류 신고 내용]\n대신공업사와 신촌상사의 공통 글자는 '신'과 '사' 입니다.\n그러므로 1번뿐 아니라 3번도 맞는 답 아닌가요??\n[해설작성자 : 이상하군]\n\n[관리자 입니다.\n문제지 사진원본 확인해 봤는데\n확정답안은 1번이네요.\n다른 문제집 확인 가능한분 계시면 확인 부탁 드립니다.\n신고시 출판사명까지 기제 부탁 드립니다.]\n\n[오류신고 반론]\n저도 3번도 해당가능한 줄 알았는데..음\n‘%사%’는 모든 공급자들이 ‘사’라는 단어를 포함하므로 결과값으로 모든 공급자들이 출력되야 맞습니다.\n반면에 정답인 ‘신’이 들어가는 결과값은 2개가 맞습니다\n[해설작성자 : 또르링]\n\n[오류신고 반론]\n3번의 경우 대신공업사, 삼진사, 삼양사, 진아공업사, 신촌상사 모두 해당됩니다.\n다섯 개 모두 문자열에 '사'가 들어가니까요.\n3번이 답이 되려면 '%신%사%'가 되야합니다.\n[해설작성자 : 냠냠]\n\n[오류신고 반론]\nSELECT * FROM 공급자 WHERE\n공급자명 LIKE '%신%';\n-> 공급자명에 \"신\"이 포함된 : 대신공업사, 신촌상사\n\nSELECT * FROM 공급자 WHERE\n공급자명 LIKE '%대%\n-> 공급자명에 \"대\"가 포함된 : 대신공업사\n\n3.SELECT * FROM 공급자 WHERE\n공급자명 LIKE '%사%';\n-> 공급자명에 \"사\"가 포함된 : 대신공업사, 삼진사, 삼양사, 진아공업사, 신촌상사\n\n4.SELECT * FROM 공급자 WHERE\n공급자명 IS NOT NULL;\n-> 공급자명이 NULL이 아닌 값 : 대신공업사, 삼진사, 삼양사, 진아공업사, 신촌상사\n[해설작성자 : kecoz]"
      },
      {
        "problem_number": 42,
        "comment": "시스템 카탈로그는 DBMS가 스스로 생성하고 유지하기 때문에, INSERT, DELETE, UPDATE문으로 시스템 카탈로그를 갱신하는 것은 허용되지 않습니다.\n[해설작성자 : 취업시켜조]"
      },
      {
        "problem_number": 43,
        "comment": "데이터 제약조건\n 개체 무결성 제약 조건 : 기본 키를 구성하는 어떤 속성도 Null값이나 중복값을 가질 수 없다.\n 도메인 무결성 제약 조건 : 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다.\n 참조 무결성 제약 조건 : 외래키의 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다.\n이거 관련 문제 2015~2020까지 개체 무결성만 나왔던 걸로 기억\n[해설작성자 : 거상 주작섭]\n\n참조 무결성 제약 조건 :\n릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다.\n외래키 값은 참조 릴레이션의 기본키 값과 동일해야 한다.\n[해설작성자 : 전자공학도]"
      },
      {
        "problem_number": 44,
        "comment": "마름모 : 관계\n사각형 : 개체\n선 : 관계-속성 연결\n[해설작성자 : comcbt.com 이용자]"
      },
      {
        "problem_number": 45,
        "comment": "1. 개체 무결성 : 기본키는 null 값이 될 수 없음\n2. 참조 무결성 : 외래키는 참조할 수 없는 값을 가질 수 없음\n3. 도메인 무결성 : 특정 속성값은 그 속성이 정의된 도메인에 속한 값이어야 함\n[해설작성자 : 오니]"
      },
      {
        "problem_number": 46,
        "comment": "로킹 단위가 크면 나머지가 다 작아짐 / 로킹 단위가 작으면 나머지가 다 커짐\n[해설작성자 : !]\n\n* 로킹 단위가 작은 경우\n예를들어 레코드와 같은 작은 단위로 잠그면 여러개를 잠궈야하기 때문에 관리가 복잡해져서 오버헤드(처리시간,메모리)가 증가하고 단위가 작으므로 일부 잠궈도 나머지 사용할 수 있는 개수가 많으므로 병행성(=공유도)가 높아진다\n\n* 로킹이 큰 경우(위와 반대로 생각)\n오버헤드가 감소하고 병행성(=공유도)가 낮아진다.\n작은 단위는 레코드 단위로 잠근다 생각하고 큰 단위는 데이터베이스 단위로 잠근다고 생각하면 떠올리기 쉽다\n[해설작성자 : 합격드가자~]"
      },
      {
        "problem_number": 47,
        "comment": "카디널리티=행\n디그리(차수)=열\n'카행', '디열(차열)'로 암기\n[해설작성자 : 마산 양덕동 내년 사십]\n\n*열차 = 열+차수(degree)\n*비행기 = (비)+행+기수(cardinality)\n[해설작성자 : 센딘]"
      },
      {
        "problem_number": 48,
        "comment": "-관계 데이터 모델에서 데이터의 가장 작은 논리적 단위는 애트리뷰트 값이며, 이 값은 원자 값만을 허용한다.\n-같은 타입의 모든 원자 값들의 집합을 그 애트리뷰트의 도메인이라고 한다.\n-도메인은 같은 도메인의 값들끼리 비교가 허용된다.\n-하나의 도메인에 대하여 둘 이상의 애트리뷰트가 정의될 수도 있다.\n-한 릴레이션에서는 모든 애트리뷰트들의 이름이 반드시 달라야 한다.\n[해설작성자 : 나좀뽑아줘]\n\n②튜플 : 릴레이션을 구성하는 각각의 행을 말한다. 속성의 모임으로 구성된다. 파일 구조에서 레코드와 같은 의미이다. 튜플의 수를 카디널리티(cardinality) 또는 기수, 대응수라고 한다.\n[해설작성자 : 취업뿌숨]\n\n다형성 - 하나의 객체가 여러 가지 타입을 가질 수 있는 것\n[해설작성자 : 전자공학도]\n\n엔티티: 데이터베이스의 논리적 구성요소, 데이터베이스에 표현하려는 유형, 무형의 개체로 정보의 단위\n[해설작성자 : 합격하장]\n\n원자값이라고 언급이 되면 무조건 도메인\n\n튜플 -> 각각의 행\n다형성 -> 나 다향(형)해~~ 여러가지 가지고 있어\n엔티티 -> 데이터베이스 형태를 띈 단위\n[해설작성자 : 몽실이]"
      },
      {
        "problem_number": 49,
        "comment": "슈퍼키 : 유일성을 만족하는 속성 또는 속성들의 집합\n후보키 : 유일성과 최소성을 만족하는 속성 또는 속성들의 집합\n대체키 : 기본키로 선택되지 못한 후보키\n외래키 : 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합\n[해설작성자 : Ant]\n\n기본키(Primary key)\n기본키는 후보키 중에서 특별히 선정된 주키(Main Key)이며 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다. 기본키는 중복된 값을 가질 수 없으며 NULL값을 가질 수 없다.\n\n대체키(Alternate Key)\n대체키는 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미한다. 대체키를 보조키라고도 한다.\n\n슈퍼키(Super Key)\n슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키를 말한다. 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타내지 않는다. 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못한다.\n\n외래키(Foreign Key)\n외래키는 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미한다. 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인상에서 정의되었을 때의 속성 A를 외래키라고 한다. 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다."
      },
      {
        "problem_number": 50,
        "comment": "SELECT 조회\nFROM 테이블\nWHERE 조건\n\n＜0단계＞ 'SELECT 조회' 할 데이터 지정\n'과목번호' 와 '과목이름' 을 출력해야 한다. (SELECT 과목번호, 과목이름;)\n[실행결과] 에서 '과목번호' 와 '과목이름' 을 출력해야 하는 것을 알 수 있다.\n'과목번호' 와 '과목이름' 을 출력하는 명령어는\n'SELECT 과목번호, 과목이름'\n이다.\n\n＜1단계＞ 'FROM 테이블' 지정 : 'SELECT 조회' 할 데이터를 가져올 테이블 지정\n'과목번호' 와 '과목이름' 이 저장되어 있는 테이블은 [R2] 테이블이므로 여기에서 데이터를 가져와야 한다. (FROM R2;)\n'과목번호' 와 '과목이름' 은 '[R2] 테이블' 에서 가져올 수 있다. (== FROM R2)\n\n＜2단계＞ 'WHERE 조건' 지정\n'과목번호' 와 '과목이름' 이 각각 'C100, 컴퓨터구조, C200, 데이터베이스' 인 '무엇' 을 찾아야 한다\n[실행결과] 의 '과목번호' 와 '과목이름' 을 보면 각각 'C100, 컴퓨터구조, C200, 데이터베이스' 인 것을 알 수 있다\n＜0단계> 에서 'FROM R2' 를 했으니 일단 '[R2] 테이블'을 살펴보자.\n[실행결과] 에서 '과목번호' 와 '과목이름' 이 'C100, 컴퓨터구조' AND 'C200, 데이터베이스' 인 '무엇'을 찾아야 한다는 것을 알 수 있다.\n(그 무엇은 '학번'이다.)\n('C100, 컴퓨터구조' 인 것 중에서(AND), 'C200, 데이터베이스' 인 것에 해당하는 '학번' 을 찾아야 한다)\n\n '학번'\n 1000 : 'C100, 컴퓨터구조' + ' '\n 2000 : ' ' + 'C200, 데이터베이스'\n** 3000 : 'C100, 컴퓨터구조' + 'C200, 데이터베이스' **\n 4000 : ' ' + 'C200, 데이터베이스' + 'C300, 운영체제'\n\n위의 표를 살펴보면 'C100, 컴퓨터구조' 인 것 중에서(AND), 'C200, 데이터베이스' 에 해당하는 '학번'은 '3000' 인 것을 알 수 있다\n\n＜3단계＞\n'학번'은 '[R1] 테이블'에 있으므로 [R1] 테이블을 살펴보자\n[R1] 테이블에서 '학번 == 3000' 에 해당하는 정보는\n\n학번 이름 학년 학과 주소\n3000 강남길 2 전자공학 경기\n\n이다\n\n＜4단계＞\n필요한 정보가 모두 모였다. 이것들을 모두 모아보면 아래와 같다\n\nSELECT R2 과목번호, R2 과목이름\nFROM R1, R2\nWHERE R1.학번 = R2.학번\nAND R1.학과 = '전자공학' AND R1.이름 = '강남길';\n\n→ ＜1단계＞ [R2] 테이블에서 '과목번호' 와 '과목이름' 을 가져온다.(SELECT R2.과목번호, R2.과목이름 FROM R2;)\n→ ＜3단계＞ [R1] 테이블에서 '학과' 와 '이름' 을 가져온다. (R1.학과 = '전자공학' AND R1.이름 = '강남길' FROM R1;)\n→ [R1] 테이블에서도 데이터를 가져오고, [R2] 테이블에서도 데이터를 가져오고 있다.\n→ 이 두 조건에 맞게 테이블을 지정하려면 'FROM R1, R2' 로 표현해야 한다\n\n('R1.학과' 라는 것은 R1 테이블에 있는 학과 라는 뜻이다.)\n('R1.이름' 이라는 것은 R1 테이블에 있는 이름 이라는 뜻이다.)\n('R2.과목번호' 라는 것은 R2 테이블에 있는 과목번호 라는 뜻이다.)\n('R2.과목이름' 이라는 것은 R2 테이블에 있는 과목이름 이라는 뜻이다.)\n\n→ WHERE 에서 'R1.학번 = R2.학번' 인 이유는 [R1] 테이블 과 [R2] 테이블 의 '연결고리'(두 테이블 모두에 있는 데이터)가 '학번'이기 때문이다.\n→ 위 문장의 SQL 표현법은 'R1.학번 = R2.학번' 이다.\n\n('R1.학번' 이라는 것은 R1 테이블에 있는 학번 이라는 뜻이다.)\n('R2.학번' 이라는 것은 R2 테이블에 있는 학번 이라는 뜻이다.)\n[해설작성자 : 너의목소리]"
      },
      {
        "problem_number": 51,
        "comment": "(1) 분해 규칙 : X -> YZ이면 X -> Y와 X -> Z이다.\n(3) 반사 규칙 : X -> Y이면 X -> Y와 X -> X이다.\n(4) 결합 규칙 : X -> Y이고 X -> Z이면 X - > YZ이다.\n[해설작성자 : ㅋㅋ루삥뽕]\n\n아래와 같은 오류 신고가 있었습니다.\n여러분들의 많은 의견 부탁 드립니다.\n추후 여러분들의 의견을 반영하여 정답을 수정하도록 하겠습니다.\n참고로 정답 변경은 오류 신고 5회 이상일 경우 수정합니다.\n\n[오류 신고 내용]\n오류신고\n반사규칙은 X ⊇ Y이면 X -> Y와 X -> X이다.\n입니다.\n\n[추가 오류 신고]\n지문의 보기에 해당하는 내용은 4번\n[해설작성자 : comcbt.com 이용자]\n\n[오류신고 반론]\n지문 보기에 해당하는 내용 2번 이행 규칙입니다. 추가 오류신고 4번이라고 하신 분 틀리셨어요!"
      },
      {
        "problem_number": 52,
        "comment": "D2 D3\n1 A 가 포함된\n\nD1 D2 D3\na 1 A\nb 1 A 중\n\nD2 D3\n1 A 를 제거\n\nD1\na\nb 결과 값\n[해설작성자 : !]"
      },
      {
        "problem_number": 53,
        "comment": "트리거 : 데이터페이스가 미리 정해 놓은 조건이 충족되거나, 특정테이블에 삽입, 수정, 삭제 등의 데이터 변경 이벤트가 발생하면 DBMS 에서 자동적으로 실행되도록 구현한 프로그램\n[해설작성자 : G다다]\n\n무결성(integrity) : 데이터의 무결성은 데이터의 정확성, 일관성, 유효성이 유지되는 것을 말한다. 데이터의 무결성을 유지하는 것은 데이터베이스 관리시스템 (DBMS)의 중요한 기능이며, 주로 데이터에 적용되는 연산에 제한을 두어 데이터의 무결성을 유지한다.\n잠금(lock) : 삽입, 삭제, 갱신 등의 트랜잭션이 일어나는 동안 DBMS의 테이블, 행이나 열 등의 요소들은 잠기게 된다.\n복귀(rollback) : 작업 중 문제가 발생되어 트랜잭션의 처리과정에서 발생한 변경사항을 취소하는 명령어\n*트랜잭션(Database Transaction) : 데이터베이스 관리 시스템 또는 유사한 시스템에서 상호작용의 단위\n[해설작성자 : 전자공학도]"
      },
      {
        "problem_number": 54,
        "comment": "DELETE는 UPDATE, SELECT, INSERT와 같은 DML 문\n[해설작성자 : Ruinak]\n\n1. DDL (정의)\n -CREATE (정의)\n -ALTER (변경)\n -DROP (삭제)\n2. DML (조작)\n -SELECT (검색)\n -INSERT (삽입)\n -DELETE (삭제)\n -UPDATE (갱신)\n3. DCL (제어)\n -COMMIT (완료)\n -ROLLBACK (되돌림)\n -GRANT (권한부여)\n -REVOKE (권한취소)\n[해설작성자 : 다산보안관]"
      },
      {
        "problem_number": 55,
        "comment": "정규화는 논리적 설계 단계에서 수행하는 작업이다.\n[해설작성자 : ㅇㅅㅇ]"
      },
      {
        "problem_number": 56,
        "comment": "인덱스는 데이터 레코드를 빠르게 접근하기 위해 [키, 값, 포인터] 쌍으로 구성되는 데이터 구조임\n- 데이터 베이스의 물리적 구조와 밀접한 관계를 가짐\n- 너무 많이 지정하면 오버헤드가 발생할 수 있으므로 적절히 지정해야 함\n[해설작성자 : 오리]\n\n트랜잭션 : 쪼갤 수 없는 업무 처리의 최소 단위\n[해설작성자 : comcbt.com 이용자]"
      },
      {
        "problem_number": 57,
        "comment": "SQL 논리 연산자(복합조건)에는 AND, OR, NOT이 있다.\n[해설작성자 : 22년 1회차 필기준비생]"
      },
      {
        "problem_number": 58,
        "comment": "로킹기법 : 같은 자원을 엑세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜젝션의 순차적 진행을 보장하는 직렬화 기법.\n타임스탬프 기법 : 트랜젝션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임스탬프를 부여하여 부여된 시간에 따라 트랜젝션 작업을 수행하여 트랜잭션 간의 처리순서를 미리 정하는 기법\n[해설작성자 : 야쿠르트]"
      },
      {
        "problem_number": 59,
        "comment": "후보키는 유일성 O 최소성 O\n + 슈퍼키는 유일성 O 최소성 X\n 키를 묻는 문제도 나왔었음(2015~2020)\n[해설작성자 : 거상 주작섭]"
      },
      {
        "problem_number": 60,
        "comment": "1NF 조건 : 원자값으로 구성\n2NF 조건 : 부분 함수 종속 제거 (완전 함수적 종속 관계)\n3NF 조건 : 이행 함수 종속 제거\nBCNF 조건 : 결정자 함수 종속\n4NF 조건 : 다중값(다치) 종속성 제거\n5NF 조건 : 조인 종속성 제거\n[해설작성자 : 나좀뽑아줘]\n\n1. 1NF 조건\n2. 3NF 조건\n3. 4NF 조건\n4. 2NF 조건\n[해설작성자 : 전자공학도]"
      }
    ]
  },
  {
    "title": "4과목 프로그래밍 언어 활용",
    "comments": [
      {
        "problem_number": 61,
        "comment": "Temporal Cohension(시간적 응집도)를 설명하는 문제이다.\n\n- Logical Cohension(논리적 응집도): 모듈 내 구성 요소들이 같은 범주에 속하는 기능끼리 묶인 경우(ex. 새글, 불러오기, 저장하기, 다른이름으로 저장하기)\n- Coincidental Cohension(우연적 응집도): 모듈 내 구성 요소들이 뚜렷한 관계없이 묶인 경우\n- Sequential Cohension(순차적 응집도): 모듈 내 구성 요소들이 이전의 명령어로부터 나온 출력결과를 그 다음 명령어의 입력자료로 사용하는 경우(ex. 총점과 평균의 관계)\n[해설작성자 : ㄱㄱㅇ]"
      },
      {
        "problem_number": 62,
        "comment": "(1) FTP 프로토콜 구조의 허점을 이용한 공격\n(2) SQL의 논리적 에러를 이용한 공격\n(4) 웹 루트 디렉토리 외부에 저장된 파일 또는 디렉토리에 접근하는 공격방법\n\n(1)은 네트워크 공격방법, (2),(4)는 웹관련 공격방법 (3)은 어플리케이션 공격방법\n[해설작성자 : ㅋㅋ루삥뽕]"
      },
      {
        "problem_number": 63,
        "comment": "HTTP/FTP/SMTP ---> OSI7계층 중 7층인 응용계층에서 동작\nTCP--------------> OSI7계층 중 4층인 전송계층에서 동작(인터넷4계층에서도 3계층 전송계층 = 동일 층)\nHTTP(Hyper Text Transfer Protocol)\nFTP(File Transfer Protocol)\nSMTP(Simple Mail Transfer Protocol)\nTCP(Transmission Control Protocol)---> 단어 그 자체로도 전송계층에서 동작하는 프로토콜임을 알 수 있다.\n[해설작성자 : 통신마왕(부경대 정보통신공학과 레전설)]"
      },
      {
        "problem_number": 64,
        "comment": "IPv6\n 128비트 주소를 사용 주소부족 문제 해결 및 자료 전송 속도 빠름\n 인증성 기밀성 데이터 무결성 지원으로 보안문제 해결\n 확장성 융통성 연동성이 뛰어나며 실시간 흐름 제어로 향상된 멀티미디어 기능 지원\n 16비트 씩 8부분 총 128비트로 구성\n 유니캐스트(unicast) 멀티캐스트(multicast) 애니캐스트(anycast) 세 가지 주소 체계\n[해설작성자 : !]\n\n1번 보기는 IPv4의 해당합니다.\n주소체계를 기준으로 보면 다음과 같습니다.\nIPv4는 32비트(예를 들면 192.168.1.0)이며 IPv6은 128비트입니다.\n참고로 제가 예로 든 IP주소는 일반적인 공유기(netis기준)입니다.\nIPTIME(공유기)을 기준으로 하면 192.168.0.0입니다.\n128비트인 IPv6의 IP주소는 16진수까지 써야 돼서 저도 예를 들지는 못 할 것 같습니다.\n[해설작성자 : comcbt.com 이용자]"
      },
      {
        "problem_number": 65,
        "comment": "- Detection(탐지) : 교착상태 발생을 허용하고 발생 시 원인을 규명하여 해결 (ex 자원할당 그래프)\n- Avoidance (회피) : 교착상태 가능성을 배제하지 않고 적절하게 피해나가는 방법 (ex 은행원 알고리즘)\n- Recovery (복구) : 교착상태 발견 후 현황대기를 배제시키거나 자원을 중단하는 메모리 할당 기법 (ex 선점, 프로세스 중지(희생자 선택)\n- Prevention(예방) : 교착상태의 필요조건을 부정함으로써 교착상태가 발생하지 않도록 미리 예방하는 방법 (ex 환형대기, 비선점, 점유와 대기, 상호배제 4가지 부정)\n[해설작성자 : 해군본부 정체단 674기 수뱅]"
      },
      {
        "problem_number": 66,
        "comment": "who 명령어는 현재 시스템에 로그인한 유저의 목록을 보여 준다.\n|(파이프)는 앞의 who 명령어의 출력 결과를 뒤의 grep 명령어로 전달한다.\ngrep 명령어는 who 명령문의 결과 중 wow 유저가 로그인하면 그 결과를 필터링하여 출력한다.\nsleep 명렁문 뒤의 숫자(초)만큼 잠시 수행을 대기한다.\n[해설작성자 : 오씨]\n\nuntil....do : 조건문이 참이 될 때까지 실행\n[해설작성자 : 지원]"
      },
      {
        "problem_number": 67,
        "comment": "교착상태 발생의 필요 충분 조건은\n상호 배제, 점유와 대기, 환형 대기 , 비선점입니다.\n[해설작성자 : voidmyhead]\n\n[교착상태 필요충분 조건 외우는번]\n상_호배제\n점_유와대기\n완(환)_형대기\n비_선점\n[해설작성자 : 맛있는짬밥(티스토리 Bettercoder)]"
      },
      {
        "problem_number": 68,
        "comment": "a[시작점 : 끝점 : 넘어가는 수] 이렇게 생각하시면 됩니다.\na[:7:2]이면, a[0]~a[6]까지의 값 [0,10,20,30,40,50,60]이고,\n이를 2칸씩 넘어가라 했으니 a[0]부터 시작해서 [0,20,40,60]이 나오게 됩니다.\n[해설작성자 : MSJ]"
      },
      {
        "problem_number": 69,
        "comment": "기본 헤더 크기는 최소 20byte 최대 60byte / 헤더에 Option값 포함 시 최대 40byte 추가 가능\n[해설작성자 : !]"
      },
      {
        "problem_number": 70,
        "comment": "리스트 타입 : 가변형\n튜플 타입 : 불변형\n[해설작성자 : comcbt.com 이용자]\n\n시퀀스- 리스트 - 순서있고,가변 [1,2,3]\n시퀀스- 튜플 - 순서있고,불변 (1,2,3)\n세트 - 세트 - 순서없고,중복x {1,2,3}\n맵 - 딕셔너리- 순서없고,key-value쌍 {'a':1,'b:2,'c':3}\n[해설작성자 : comcbt.com 이용자]"
      },
      {
        "problem_number": 71,
        "comment": "0부터 시작해서 4보다 작은 정수\n+는 1씩 증가\n[해설작성자 : 낼시험]"
      },
      {
        "problem_number": 72,
        "comment": "Locality : 어느 한순간에 특정 부분을 집중적으로 참조\nThrashing : 지나치게 페이지 부재가 발생함으로 인하여 전체 시스템의 성능이 저하되는 현상\n[해설작성자 : 좀비]\n\nDeadlock : 교착상태. 두 개 이상의 작업이 서로 작업이 끝나기 만을 기다리고 있는 것\n[해설작성자 : 수도공고갤러리 갤주]"
      },
      {
        "problem_number": 73,
        "comment": "HRN 스케줄링 방식\n- 비선점 스케줄링\n 실행시간이 긴 프로세스에 불리한 SJF 을 보완하기 위해\n 대기시간 및 서비스 시간을 이용\n 우선순위를 계산 숫자가 높은것부터 낮은순으로 순위 부여\n (대기시간 + 서비스시간) / 서비스시간 = 우선순위값\n[해설작성자 : 거상 주작섭]"
      },
      {
        "problem_number": 74,
        "comment": "페이징 기법 : 컴퓨터가 메인 메모리에서 사용하기 위해 데이터를 저장하고 검색하는 메모리 관리 기법\n페이징기법을 통해 물리적 메모리는 연속적으로 할당되어 존재할 필요가 없음\n페이징기법을 통해 비연속적 메모리를 연속적메모리처럼 만들 수 있음\n\n*페이지 크기가 작은경우\n더 많은 페이징 사상테이블 필요\n내부 단편화 감소\n페이지의 집합을 효율적으로 운영가능\n기억장치의 효율이 좋음\n총 입출력 시간 증가\n\n*페이지크기가 큼\n주기억 장치 공간 절약\n참조되는 정보와 무관한 양의 정보가 주기억 장치에 남게 됨\n테이블이 복잡하지 않아 관리 용이\n[해설작성자 : comcbt.com 이용자]"
      },
      {
        "problem_number": 75,
        "comment": "표준 라이브러리가 기본적으로 포함되어 있는 라이브러리고,\n외부 라이브러리가 인터넷등에 공유되어 있는 라이브러리라 다운받아 설치가 필수임\n[해설작성자 : 또르링]"
      },
      {
        "problem_number": 76,
        "comment": "str1[1]=str2[2] => str1의 KOREA중 O가 V로 변경\nstr1= KVREA\nstr2[3]=str1[4] =>str2의 LOVE중 E가 A로 변경\nstr2=LOVA\n\np1+2= str1[2]= R\n[해설작성자 : 영남이공대 소프트웨어콘텐츠과]\n\n덧붙이자면\nstrcat(str1, str2);에 의해\nstr1 => \"KVREALOVA\"가 됩니다.\n[해설작성자 : 현직]\n\nchar str1 [20] = KOREA\n*20개의 칸이 있고, 맨앞에서부터 KOREA가 들어감\nchar str2 [20] = LOVE\n*20개의 칸이 있고, 맨앞에서부터 LOVE가 들어감\n\np1=str1 (p1을 str1이라고 여김) p2=str2 (p2을 str2이라고 여김)\n\nstr1[1]=p2[2]\n*p2(str2)의 2번째인 O를 str1(p1)의 1번째인 O에 삽입.\nstr1 = KVREA\n\nstr2[3]=p1[4]\n*p1(str1)의 4번째 A를 str2(p2)의 3번째인 V에 삽입.\nstr2=LOVA\n\nstrcat에 의해 str2를 str1 뒤로 붙임.\nKVREALOVE라는 값이 나옴.\n\n여기서 p1+2(str1[2])를 구하면 2번째인 R.\n\n**혹시나 해서 말하지만 첫칸은 1이 아니라, 0이에요.\n[해설작성자 : 친절한 설명]"
      },
      {
        "problem_number": 77,
        "comment": "제어가 없으니 신뢰성이 낮음\n4번을 제외한 나머지는 전부 TCP에관한 설명\n[해설작성자 : 또르링]"
      },
      {
        "problem_number": 78,
        "comment": "데이터 타입 유형\n\nChar(문자) = 문자 하나를 저장\nString(문자열) = 나열된 여러 개의 문자\n[해설작성자 : 수박]"
      },
      {
        "problem_number": 79,
        "comment": "{14 ,22, 30, 38 }\n주소값 10,11,12,13 / 14,15,16,17 / 18,19,20,21 / 22,23,24,25\n자리값 a(0) a(1) a(2) a(3)\n*1개의 주소값 : 1Byte\n\nprintf(\"%u, \", &a[2]; a[2]자리의 첫번째 주소값 18\nprintf(\"%u\", a); a[0]자리의 첫번째 주소값 10\n[해설작성자 : 루니]\n\n배열은 자료형이 같은 변수를 메모리에 연속으로 할당합니다.\nint형인 배열 요소 14, 22, 30, 38은 제시된 문제에 따라 메모리 10번지부터 시작하여 4바이트 간격으로 각각 10, 14, 18, 22번지의 주소값을 할당 받습니다.\n%u <--- 부호 없는 10진수로 출력하는 변환 문자입니다.\nprintf(\"%u, \", &a[2]); <--- &a[2]는 &a + 2 또는 10 + (2 * sizeof(int)) 이며 18입니다. 18번지부터 21번지까지의 총 4바이트 저장 공간인 주소 값을 뜻합니다.\nprintf(\"%u\", a); <--- 배열명은 첫 번째 배열 요소(a[0])의 주소값 입니다.\n“%u, \"에는 쉼표와 띄어쓰기가 있으므로 실행 결과는 18, 10 입니다.\n[해설작성자 : COOKIE]"
      },
      {
        "problem_number": 80,
        "comment": "프로세스, 메모리 관리는 커널의 기능\n[해설작성자 : 합격기원]"
      }
    ]
  },
  {
    "title": "5과목 정보시스템 구축관리",
    "comments": [
      {
        "problem_number": 81,
        "comment": "비용 산정 기법\n 전문가 감정 기법 : 조직 내에 있는 경험 많은 두 명 이상의 전문가에게 비용 산정을 의뢰하는 기법\n 델파이 기법 : 전문가 감정 기법의 주관적 편견을 보완하기 위해 많은 전문가의 의견을 종합\n LOC 기법 : 원시 코드 라인 수 기법으로서 원시 코드 라인 수의 비관치 낙관치 기대치를 측정하여 산정하는 기법\n 개발 단계별 인월수 기법 : LOC를 보완하기 위한 기법, 필요 노력을 생명 주기의 각 단계별로 선정\n COCOMO : 보헴이 제안한 것으로 LOC에 의한 비용 산정 기법\n\n유형별 COCOMO\n Organic : 조직형 / 소규모 소프트웨어 일괄 자료 처리 /5만 라인 이하\n Semi-detached : 반분리형 / 트랜잭션 처리 시스템이나 운영체제, DB / 30만 라인 이하\n Embedded : 내장형 / 최대형 규모 트랜잭션 처리 시스템이나 운영체제 / 30만 라인 이상\n\nCOCOMO 종류\n Basic (기본): 소프트웨어 크기 및 개발 유형만 이용\n Intermediate(중간) : 기본형의 공식 토대로 사용하나 4가지 특성 및 15가지 요인에 의해 비용 산정\n 제품 특성 : 신뢰도 / DB크기 / 복잡도\n 컴퓨터 특성 : 수행시간제한 / 기억장소제한 / 가상 기계의 안정성 / Turn Around Time\n 개발 요원의 특성 : 분석가 능력 / 개발 분야 경험 / 가상 기계 경험 / 프로그래머 능력 및 언어 경험\n 프로젝트 특성 : 소프트웨어 도구 이용 / 프로젝트 개발 일정 / 최신 프로그래밍 기법 이용\n Detailed(발전) : 중간형 COCOMO 보완하여 만들어진 방법으로 개발 공정별보다 자세하고 정확하게 비용 산정\n Putnam 기법 : 소프트웨어 생명 주기의 전 과정 동안에 사용될 곡선의 노력의 분포를 가정해주는 모형\n Rayleigh-Norden 곡선의 노력 분포도를 기초로 한다.\n FP 기법 : 기능 점수 모형으로 알브레히트가 제안 / 요인별 가중치를 합산하여 총 기능 점수를 산출하여 점수와 영향도를 이용 비용 산정\n[해설작성자 : 거상 주작섭]"
      },
      {
        "problem_number": 82,
        "comment": "tcp/ip 통신에서, tcp는 3-way handshake 를 통해 통신이 원활히 이뤄질 수 있는지를 확인합니다.\n[해설작성자 : 김구름]\n\ntcp wrapper는 tcp 3-way handshake 인증 과정 직후에 수행됩니다.\n[해설작성자 : 얼뽀]"
      },
      {
        "problem_number": 83,
        "comment": "MQTT : 메세지 큐잉(QUEUING) 텔레메트리\n[해설작성자 : 겸사]"
      },
      {
        "problem_number": 84,
        "comment": "서비스 공격 유형\n DoS (서비스 거부) : 표적이 되는 서버의 자원을 고갈시킬 목적으로 다수 공격자 or 시스템에서 대량의 데이터를 한 곳에 집중적으로 전송함\n Ping of Death (죽음의 핑) : Ping 명령을 전송할 때 패킷의 크기를 인터넷 프로토콜 허용범위 이상으로 전송하여 공격 대상의 네트워크를 마비시키는 서비스 거부 공격\n Smurfing : IP나 ICMP의 특성을 악용 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만드는 공격 방법.\n SYN Flooding : TCP는 신뢰성 있는 전송을 위해 3-way-handshake를 거친 후 데이터를 전송하는데 SYN은 공격자가 가상의 클라이언트로 위장 3WH을 의도적으로 중단, 서버가 대기상태에 놓여 정상 서비스를 못하게 하는 공격 방법\n TearDrop : Offset 값을 변경시켜 수신 측에서 패킷을 재조립할 때 오류로 인한 과부하를 발생 시킴\n Land : 패킷을 전송할 때 송 수신 IP주소를 모두 공격대상 IP주소로 하여 공격대상에게 전송하는 것, 공격대상은 송신IP주소가 자신이기 때문에 자신에게 무한히 응답하게 되는 공격\n DDoS(분산 서비스 거부) : 여러 곳에 분산된 공격 지점에서 한 곳의 서버에 대해 분산 서비스 공격을 수행\n[해설작성자 : 거상 주작섭]"
      },
      {
        "problem_number": 85,
        "comment": "초기단계(initial) / 반복단계 (Repeatable) / 정의단계 (Defined) / 관리단계 (Managed)Tip. 정량적 프로세스 관리가 Keyworkd / 최적단계 (Optimizing)/\n[해설작성자 : 정보처리Knight_MR.K]"
      },
      {
        "problem_number": 86,
        "comment": "하드웨어적으로 구현되므로 소프트웨어식 암호 기술에 내재된 보안 취약점을 해결할 수 있다.\n[해설작성자 : 코봉이]"
      },
      {
        "problem_number": 87,
        "comment": "VLAN(Virtual Local Area Network)\n: 물리적 배치와 상관없이 논리적으로 LAN을 구성\nBroadcast Domain을 구분할 수 있게 해주는 기술로 접속된 장비들의 성능향상 및 보안성 증대 효과\n\nSTP(Spanning Tree Protocol)\n: 2개 이상의 스위치가 여러 경로로 연결될 때,\n무한 루프 현상을 막기 위해서 우선순위 따라 1개의 경로로만 통신하도록 하는 프로토콜\n\nARP(Address Resolution Protocol)\n: 네트워크 상에서 IP 주소를 물리적 네트워크 주소로 대응(bind)시키기 위해 사용되는 프로토콜,\n (IP를 MAC주소로 바인딩)\n[해설작성자 : 한비로]\n\nL2AN(Layer 2 영역을 의미하는 일반적인 개념)\nMAC 주소를 기반으로 프레임을 전송하고 동일 네트워크 간 연결만 가능함\n[해설작성자 : llana]"
      },
      {
        "problem_number": 88,
        "comment": "방화벽 설정의 잘못된 조작으로 인한 네트워크, 서버 보안 위협 - 기술적\n[해설작성자 : 너굴맨]"
      },
      {
        "problem_number": 89,
        "comment": "Wm-Bus:무선 미터버스, 산업용 무선 프로토콜\nDigital Twin:컴퓨터 시뮬레이션(가상화)을 통해 결과를 예측하는 기술\nZigbee:직비, 무선 메시 네트워크의 표준(저가, 저전력)\n[해설작성자 : ㅇ]\n\nDigital Twin : 물리적인 사물과 컴퓨터에 동일하게 표현되는 가상의 모델로 실제 물리적인 자산 대신 소프트웨어로 가상화함으로써 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있고, 자산 최적화, 돌발사고 최소화, 생산성 증가 등 설계부터 제조, 서비스에 이르는 모든 과정의 효율성을 향상시킬 수 있는 모델\n[해설작성자 : sextuple_u]"
      },
      {
        "problem_number": 90,
        "comment": "계획 수립 → 위험 분석 → 개발 및 검증 → 고객 평가\n[해설작성자 : comcbt.com 이용자]\n\n쉽게 외우는 법\n\n계획 '수'립 - 위험 '분'석 - 개발 및 검'증' - 고객 평'가'\n→ '수분증가'\n[해설작성자 : 컴퓨터전문가]"
      },
      {
        "problem_number": 91,
        "comment": "소프트웨어 생명 주기 모형\n폭포수 : 선형 순차적 / 메뉴얼 작성 / 각 단계가 끝난 뒤 다음 단계로 넘어감\n 타당성 검토 - 계획 - 요구분석 - 설계 - 구현 - 시험 - 유지보수\n프로토 : 원형 모형으로 실제 개발될 제품의 견본을 만들어 결과물을 예측하는 모형\n 개발이 완료된 시점에서 오류가 발견되는 폭포수 모형 보완\n 요구수집 - 설계 - 구축 - 고객평가 - 조정 - 구현\n나선형 : 점진적 모형 / 위험을 관리 및 최소화하는 것이 목적 / 유지보수가 필요 없다\n애자일 : 고객 중심적 모형 / 일정 주기를 반복하면서 개발과정 진행\n[해설작성자 : 거상 주작섭]"
      },
      {
        "problem_number": 92,
        "comment": "* 하드웨어 관련 신기술\n 1. Memristor : memory + register. 전원 공급이 끊어져도 다시 전원이 공급되면 이전 상태 복원\n 2. MEMS : 센서, 엑추에이터 등 기계구조를 다양한 기술로 미세 가공 후 전기기계적 동작 가능케 한 초미세장치\n 3. SNMP : 하드웨어 신기술 아님. 간이 망 관리 프로토콜\n 4. N-Screen : N개의 서로 다른 단말기에서 동일콘텐츠를 자유롭게 이용 가능한 서비스\n[해설작성자 : 78]"
      },
      {
        "problem_number": 93,
        "comment": "대칭 암호화 알고리즘은 키 교환이 필요하기 때문에 키를 교환하는 중 키가 탈취될 수 있다는 문제가 있다.\n공개 암호화 방식에 비해 속도가 빠르다.\n[해설작성자 : 코봉이]\n\n대칭 암호 알고리즘은 비밀키(Private Key)를 공유해야 하므로 키 교환이 필요함\n[해설작성자 : 공부하자]"
      },
      {
        "problem_number": 94,
        "comment": "해쉬 함수를 이용한 해쉬 암호화 방식은 단방향 암호화이다.\n[해설작성자 : 뿅]\n\n암호화 방식은 크게 양방향과 단방향으로 구분됨\n1. 양방향\n (1) 개인키\n - 스트림 방식: RC4, LFSR\n - 블록 방식: DES, SEED, AES, ARIA\n (2) 공개키\n2. 단방향\n (1) 해시\n\n해시함수는 단방향 암호화 방식으로 양방향 방식인 스트림 방식과는 다르게 구분됨\n[해설작성자 : 오리]"
      },
      {
        "problem_number": 95,
        "comment": "나선형모델 4가지 활동 순서\n계획 수립 - 위험 분석 - 개발 및 검증 - 고객평가\n[해설작성자 : !]\n\n계획 '수'립 -> 위험 '분'석 -> 개발 및 검'증' -> 고객평'가'\n=> 수 분 증 가 로 외우시면 잘 외워집니다.\n[해설작성자 : 강썬]"
      },
      {
        "problem_number": 96,
        "comment": "개발유형에 따라 조직형(Organic), 반분리형(Semi-Detached), 내장형(Embedded)으로 구분한다.\n[해설작성자 : 코봉이]\n\n보엠이 고안한 소프트웨어 개발비용 산정 방법.\nman-month = 투입 노력\n개발 유형에 따른 3종류 - organic, semidetached, embedded\n (기본, 중간, 내장형 모드)\n[해설작성자 : 합격하자]\n\n개발 유형에 따른 3종류 - organic, semidetached, embedded\n(기본, 중간, 내장형 모드) -> (조직형,반분리형,내장형)\n[해설작성자 : 김인직]\n\nCOCOMO 모형\n - 원시 프로그램 규모(LOC)에 의한 비용 산정 기법\n - 보헴(Boehm)이 제안\n - 비교적 작은 규모의 프로젝트들을 통계 분석한 결과를 반영한 모델 -> 중소 규모 소프트웨어 프로젝트 비용 추정에 적합\n - 비용 산정 결과는 Man-Month로 표현\n\n소프트웨어 개발유형에 따른 분류\n 조직형(Organic)\n - 5만 라인 이하\n - 사무 처리용, 업무용, 과학용 소프트웨어 개발에 적합\n\n 반분리형(Semi-Detached)\n - 30만 라인 이하\n - 컴파일러, 인터프리터 개발에 적합\n\n 내장형(Embedded)\n - 30만 라인 이상\n - 미사일 유도 시스템, 실시간 처리 시스템 개발에 적합\n[해설작성자 : LBS]\n\n1~3은 COCOMO, 4는 럼바우(Rumbaugh) => 객체, 동적, 기능(object, dynamic, function)\n[해설작성자 : 내일시험]"
      },
      {
        "problem_number": 97,
        "comment": "SSO - Single Sign On 줄임말\n[해설작성자 : 지나가던 학생]\n\n시스템 인증\n - 토큰 기반 인증 : 하드웨어와 소프트웨어의 토큰 장치를 사용하는 인증 기법, 하드웨어 장치는 스마트카드를 사용, 소프트웨어 장치는 개인 식별번호를 사용하는 강력한 인증 방법\n - SSO 인증 : 여러 시스템 중 하나의 시스템에 인증을 성공하면 다른 시스템의 접근 권한도 모두 얻는 방식\n[해설작성자 : 눈딱감꼬낙하아아]"
      },
      {
        "problem_number": 98,
        "comment": "폭포수 : 선형 순차적 / 메뉴얼 작성 / 각 단계가 끝난 뒤 다음 단계로 넘어감\n 가장 오래됐고 가장 폭넓게 사용된 전통적인 모형\n 타당성 검토 - 계획 - 요구분석 - 설계 - 구현 - 시험 - 유지보수\n\n1. 선형 순차적이라 앞단계 다 끝냈는데 갑자기 뭐 들고오면 빡쳐서 안한다고 생각하시면 됩니다.\n2. 선형 순차적 oo\n3. 단계가 끝나야 다음 단계로 넘어가기에 그 단계에서의 정의 및 산출물이 명확해야합니다.\n4. 오래된 모형으로서 적용 경험 및 성공사례가 많습니다.\n[해설작성자 : 거상 주작섭]\n\n* 폭포수 - 위에서 아래로 떨어진다라는 뜻에서 선형 순차적이며 다시 거슬러올라갈 수 없기 때문에 요구사항 변경이나 전 단계 수정은 할 수 없다."
      },
      {
        "problem_number": 99,
        "comment": "1. CLASP - Comprehensive, Lightweight Application Security Process. 소프트웨어 개발 생명주기(SDLC) 초기단계에 보안강화를 목적으로 하는 정형화된 프로세스로써, 활동중심·역할기반의 프로세스로 구성된 집합체로, 이미 운영중인 시스템에 적용하기 적합합니다.\n2. CWE - Common Weakness Enumeration. 주요 보안 취약점, 보안 문제를 정리하는 프로젝트입니다.\n3. PIMS - Personal Information Management System. 개인정보 보호관리체계입니다.\n4. Seven Touchpoints - 소프트웨어 개발 생명주기(SDLC)의 각 단계에 관련된 7가지의 보안 강화 활동을 개발자에게 집중적으로 관리하도록 요구하여 실무적으로 검증된 개발보안 방법론입니다.\n[해설작성자 : 반스트]"
      },
      {
        "problem_number": 100,
        "comment": "테일러링 (Tailoring) : 프로젝트 상황 특성에 맞게 정의된 소프트웨어 개발 방법론 절차, 사용기법 등을 수정 및 보완하는 작업\n[해설작성자 : 땅혁]"
      }
    ]
  }
]